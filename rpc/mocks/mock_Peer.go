// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	mock "github.com/stretchr/testify/mock"
	"go.woodpecker-ci.org/woodpecker/v3/rpc"
)

// NewMockPeer creates a new instance of MockPeer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPeer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPeer {
	mock := &MockPeer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPeer is an autogenerated mock type for the Peer type
type MockPeer struct {
	mock.Mock
}

type MockPeer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPeer) EXPECT() *MockPeer_Expecter {
	return &MockPeer_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type MockPeer
func (_mock *MockPeer) Done(c context.Context, workflowID string, state rpc.WorkflowState) error {
	ret := _mock.Called(c, workflowID, state)

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, rpc.WorkflowState) error); ok {
		r0 = returnFunc(c, workflowID, state)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeer_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type MockPeer_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
//   - c context.Context
//   - workflowID string
//   - state rpc.WorkflowState
func (_e *MockPeer_Expecter) Done(c interface{}, workflowID interface{}, state interface{}) *MockPeer_Done_Call {
	return &MockPeer_Done_Call{Call: _e.mock.On("Done", c, workflowID, state)}
}

func (_c *MockPeer_Done_Call) Run(run func(c context.Context, workflowID string, state rpc.WorkflowState)) *MockPeer_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 rpc.WorkflowState
		if args[2] != nil {
			arg2 = args[2].(rpc.WorkflowState)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPeer_Done_Call) Return(err error) *MockPeer_Done_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeer_Done_Call) RunAndReturn(run func(c context.Context, workflowID string, state rpc.WorkflowState) error) *MockPeer_Done_Call {
	_c.Call.Return(run)
	return _c
}

// EnqueueLog provides a mock function for the type MockPeer
func (_mock *MockPeer) EnqueueLog(logEntry *rpc.LogEntry) {
	_mock.Called(logEntry)
	return
}

// MockPeer_EnqueueLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnqueueLog'
type MockPeer_EnqueueLog_Call struct {
	*mock.Call
}

// EnqueueLog is a helper method to define mock.On call
//   - logEntry *rpc.LogEntry
func (_e *MockPeer_Expecter) EnqueueLog(logEntry interface{}) *MockPeer_EnqueueLog_Call {
	return &MockPeer_EnqueueLog_Call{Call: _e.mock.On("EnqueueLog", logEntry)}
}

func (_c *MockPeer_EnqueueLog_Call) Run(run func(logEntry *rpc.LogEntry)) *MockPeer_EnqueueLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *rpc.LogEntry
		if args[0] != nil {
			arg0 = args[0].(*rpc.LogEntry)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeer_EnqueueLog_Call) Return() *MockPeer_EnqueueLog_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeer_EnqueueLog_Call) RunAndReturn(run func(logEntry *rpc.LogEntry)) *MockPeer_EnqueueLog_Call {
	_c.Run(run)
	return _c
}

// Extend provides a mock function for the type MockPeer
func (_mock *MockPeer) Extend(c context.Context, workflowID string) error {
	ret := _mock.Called(c, workflowID)

	if len(ret) == 0 {
		panic("no return value specified for Extend")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(c, workflowID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeer_Extend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Extend'
type MockPeer_Extend_Call struct {
	*mock.Call
}

// Extend is a helper method to define mock.On call
//   - c context.Context
//   - workflowID string
func (_e *MockPeer_Expecter) Extend(c interface{}, workflowID interface{}) *MockPeer_Extend_Call {
	return &MockPeer_Extend_Call{Call: _e.mock.On("Extend", c, workflowID)}
}

func (_c *MockPeer_Extend_Call) Run(run func(c context.Context, workflowID string)) *MockPeer_Extend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeer_Extend_Call) Return(err error) *MockPeer_Extend_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeer_Extend_Call) RunAndReturn(run func(c context.Context, workflowID string) error) *MockPeer_Extend_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type MockPeer
func (_mock *MockPeer) Init(c context.Context, workflowID string, state rpc.WorkflowState) error {
	ret := _mock.Called(c, workflowID, state)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, rpc.WorkflowState) error); ok {
		r0 = returnFunc(c, workflowID, state)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeer_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type MockPeer_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - c context.Context
//   - workflowID string
//   - state rpc.WorkflowState
func (_e *MockPeer_Expecter) Init(c interface{}, workflowID interface{}, state interface{}) *MockPeer_Init_Call {
	return &MockPeer_Init_Call{Call: _e.mock.On("Init", c, workflowID, state)}
}

func (_c *MockPeer_Init_Call) Run(run func(c context.Context, workflowID string, state rpc.WorkflowState)) *MockPeer_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 rpc.WorkflowState
		if args[2] != nil {
			arg2 = args[2].(rpc.WorkflowState)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPeer_Init_Call) Return(err error) *MockPeer_Init_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeer_Init_Call) RunAndReturn(run func(c context.Context, workflowID string, state rpc.WorkflowState) error) *MockPeer_Init_Call {
	_c.Call.Return(run)
	return _c
}

// Next provides a mock function for the type MockPeer
func (_mock *MockPeer) Next(c context.Context, f rpc.Filter) (*rpc.Workflow, error) {
	ret := _mock.Called(c, f)

	if len(ret) == 0 {
		panic("no return value specified for Next")
	}

	var r0 *rpc.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, rpc.Filter) (*rpc.Workflow, error)); ok {
		return returnFunc(c, f)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, rpc.Filter) *rpc.Workflow); ok {
		r0 = returnFunc(c, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, rpc.Filter) error); ok {
		r1 = returnFunc(c, f)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPeer_Next_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Next'
type MockPeer_Next_Call struct {
	*mock.Call
}

// Next is a helper method to define mock.On call
//   - c context.Context
//   - f rpc.Filter
func (_e *MockPeer_Expecter) Next(c interface{}, f interface{}) *MockPeer_Next_Call {
	return &MockPeer_Next_Call{Call: _e.mock.On("Next", c, f)}
}

func (_c *MockPeer_Next_Call) Run(run func(c context.Context, f rpc.Filter)) *MockPeer_Next_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 rpc.Filter
		if args[1] != nil {
			arg1 = args[1].(rpc.Filter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeer_Next_Call) Return(workflow *rpc.Workflow, err error) *MockPeer_Next_Call {
	_c.Call.Return(workflow, err)
	return _c
}

func (_c *MockPeer_Next_Call) RunAndReturn(run func(c context.Context, f rpc.Filter) (*rpc.Workflow, error)) *MockPeer_Next_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterAgent provides a mock function for the type MockPeer
func (_mock *MockPeer) RegisterAgent(ctx context.Context, info rpc.AgentInfo) (int64, error) {
	ret := _mock.Called(ctx, info)

	if len(ret) == 0 {
		panic("no return value specified for RegisterAgent")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, rpc.AgentInfo) (int64, error)); ok {
		return returnFunc(ctx, info)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, rpc.AgentInfo) int64); ok {
		r0 = returnFunc(ctx, info)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, rpc.AgentInfo) error); ok {
		r1 = returnFunc(ctx, info)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPeer_RegisterAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterAgent'
type MockPeer_RegisterAgent_Call struct {
	*mock.Call
}

// RegisterAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - info rpc.AgentInfo
func (_e *MockPeer_Expecter) RegisterAgent(ctx interface{}, info interface{}) *MockPeer_RegisterAgent_Call {
	return &MockPeer_RegisterAgent_Call{Call: _e.mock.On("RegisterAgent", ctx, info)}
}

func (_c *MockPeer_RegisterAgent_Call) Run(run func(ctx context.Context, info rpc.AgentInfo)) *MockPeer_RegisterAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 rpc.AgentInfo
		if args[1] != nil {
			arg1 = args[1].(rpc.AgentInfo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeer_RegisterAgent_Call) Return(n int64, err error) *MockPeer_RegisterAgent_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockPeer_RegisterAgent_Call) RunAndReturn(run func(ctx context.Context, info rpc.AgentInfo) (int64, error)) *MockPeer_RegisterAgent_Call {
	_c.Call.Return(run)
	return _c
}

// ReportHealth provides a mock function for the type MockPeer
func (_mock *MockPeer) ReportHealth(c context.Context) error {
	ret := _mock.Called(c)

	if len(ret) == 0 {
		panic("no return value specified for ReportHealth")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(c)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeer_ReportHealth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportHealth'
type MockPeer_ReportHealth_Call struct {
	*mock.Call
}

// ReportHealth is a helper method to define mock.On call
//   - c context.Context
func (_e *MockPeer_Expecter) ReportHealth(c interface{}) *MockPeer_ReportHealth_Call {
	return &MockPeer_ReportHealth_Call{Call: _e.mock.On("ReportHealth", c)}
}

func (_c *MockPeer_ReportHealth_Call) Run(run func(c context.Context)) *MockPeer_ReportHealth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeer_ReportHealth_Call) Return(err error) *MockPeer_ReportHealth_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeer_ReportHealth_Call) RunAndReturn(run func(c context.Context) error) *MockPeer_ReportHealth_Call {
	_c.Call.Return(run)
	return _c
}

// UnregisterAgent provides a mock function for the type MockPeer
func (_mock *MockPeer) UnregisterAgent(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for UnregisterAgent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeer_UnregisterAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterAgent'
type MockPeer_UnregisterAgent_Call struct {
	*mock.Call
}

// UnregisterAgent is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPeer_Expecter) UnregisterAgent(ctx interface{}) *MockPeer_UnregisterAgent_Call {
	return &MockPeer_UnregisterAgent_Call{Call: _e.mock.On("UnregisterAgent", ctx)}
}

func (_c *MockPeer_UnregisterAgent_Call) Run(run func(ctx context.Context)) *MockPeer_UnregisterAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeer_UnregisterAgent_Call) Return(err error) *MockPeer_UnregisterAgent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeer_UnregisterAgent_Call) RunAndReturn(run func(ctx context.Context) error) *MockPeer_UnregisterAgent_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockPeer
func (_mock *MockPeer) Update(c context.Context, workflowID string, state rpc.StepState) error {
	ret := _mock.Called(c, workflowID, state)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, rpc.StepState) error); ok {
		r0 = returnFunc(c, workflowID, state)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeer_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockPeer_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - c context.Context
//   - workflowID string
//   - state rpc.StepState
func (_e *MockPeer_Expecter) Update(c interface{}, workflowID interface{}, state interface{}) *MockPeer_Update_Call {
	return &MockPeer_Update_Call{Call: _e.mock.On("Update", c, workflowID, state)}
}

func (_c *MockPeer_Update_Call) Run(run func(c context.Context, workflowID string, state rpc.StepState)) *MockPeer_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 rpc.StepState
		if args[2] != nil {
			arg2 = args[2].(rpc.StepState)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPeer_Update_Call) Return(err error) *MockPeer_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeer_Update_Call) RunAndReturn(run func(c context.Context, workflowID string, state rpc.StepState) error) *MockPeer_Update_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function for the type MockPeer
func (_mock *MockPeer) Version(c context.Context) (*rpc.Version, error) {
	ret := _mock.Called(c)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 *rpc.Version
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*rpc.Version, error)); ok {
		return returnFunc(c)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *rpc.Version); ok {
		r0 = returnFunc(c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Version)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(c)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPeer_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type MockPeer_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
//   - c context.Context
func (_e *MockPeer_Expecter) Version(c interface{}) *MockPeer_Version_Call {
	return &MockPeer_Version_Call{Call: _e.mock.On("Version", c)}
}

func (_c *MockPeer_Version_Call) Run(run func(c context.Context)) *MockPeer_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeer_Version_Call) Return(version *rpc.Version, err error) *MockPeer_Version_Call {
	_c.Call.Return(version, err)
	return _c
}

func (_c *MockPeer_Version_Call) RunAndReturn(run func(c context.Context) (*rpc.Version, error)) *MockPeer_Version_Call {
	_c.Call.Return(run)
	return _c
}

// Wait provides a mock function for the type MockPeer
func (_mock *MockPeer) Wait(c context.Context, workflowID string) (bool, error) {
	ret := _mock.Called(c, workflowID)

	if len(ret) == 0 {
		panic("no return value specified for Wait")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(c, workflowID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(c, workflowID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(c, workflowID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPeer_Wait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wait'
type MockPeer_Wait_Call struct {
	*mock.Call
}

// Wait is a helper method to define mock.On call
//   - c context.Context
//   - workflowID string
func (_e *MockPeer_Expecter) Wait(c interface{}, workflowID interface{}) *MockPeer_Wait_Call {
	return &MockPeer_Wait_Call{Call: _e.mock.On("Wait", c, workflowID)}
}

func (_c *MockPeer_Wait_Call) Run(run func(c context.Context, workflowID string)) *MockPeer_Wait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeer_Wait_Call) Return(canceled bool, err error) *MockPeer_Wait_Call {
	_c.Call.Return(canceled, err)
	return _c
}

func (_c *MockPeer_Wait_Call) RunAndReturn(run func(c context.Context, workflowID string) (bool, error)) *MockPeer_Wait_Call {
	_c.Call.Return(run)
	return _c
}
