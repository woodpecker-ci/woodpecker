// Code generated by mockery. DO NOT EDIT.

//go:build test
// +build test

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	model "go.woodpecker-ci.org/woodpecker/v3/server/model"

	queue "go.woodpecker-ci.org/woodpecker/v3/server/queue"
)

// Queue is an autogenerated mock type for the Queue type
type Queue struct {
	mock.Mock
}

// Done provides a mock function with given fields: c, id, exitStatus
func (_m *Queue) Done(c context.Context, id string, exitStatus model.StatusValue) error {
	ret := _m.Called(c, id, exitStatus)

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, model.StatusValue) error); ok {
		r0 = rf(c, id, exitStatus)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Error provides a mock function with given fields: c, id, err
func (_m *Queue) Error(c context.Context, id string, err error) error {
	ret := _m.Called(c, id, err)

	if len(ret) == 0 {
		panic("no return value specified for Error")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, error) error); ok {
		r0 = rf(c, id, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ErrorAtOnce provides a mock function with given fields: c, ids, err
func (_m *Queue) ErrorAtOnce(c context.Context, ids []string, err error) error {
	ret := _m.Called(c, ids, err)

	if len(ret) == 0 {
		panic("no return value specified for ErrorAtOnce")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, error) error); ok {
		r0 = rf(c, ids, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Evict provides a mock function with given fields: c, id
func (_m *Queue) Evict(c context.Context, id string) error {
	ret := _m.Called(c, id)

	if len(ret) == 0 {
		panic("no return value specified for Evict")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(c, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EvictAtOnce provides a mock function with given fields: c, ids
func (_m *Queue) EvictAtOnce(c context.Context, ids []string) error {
	ret := _m.Called(c, ids)

	if len(ret) == 0 {
		panic("no return value specified for EvictAtOnce")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(c, ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Extend provides a mock function with given fields: c, agentID, workflowID
func (_m *Queue) Extend(c context.Context, agentID int64, workflowID string) error {
	ret := _m.Called(c, agentID, workflowID)

	if len(ret) == 0 {
		panic("no return value specified for Extend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(c, agentID, workflowID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Info provides a mock function with given fields: c
func (_m *Queue) Info(c context.Context) queue.InfoT {
	ret := _m.Called(c)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 queue.InfoT
	if rf, ok := ret.Get(0).(func(context.Context) queue.InfoT); ok {
		r0 = rf(c)
	} else {
		r0 = ret.Get(0).(queue.InfoT)
	}

	return r0
}

// KickAgentWorkers provides a mock function with given fields: agentID
func (_m *Queue) KickAgentWorkers(agentID int64) {
	_m.Called(agentID)
}

// Pause provides a mock function with no fields
func (_m *Queue) Pause() {
	_m.Called()
}

// Poll provides a mock function with given fields: c, agentID, f
func (_m *Queue) Poll(c context.Context, agentID int64, f queue.FilterFn) (*model.Task, error) {
	ret := _m.Called(c, agentID, f)

	if len(ret) == 0 {
		panic("no return value specified for Poll")
	}

	var r0 *model.Task
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, queue.FilterFn) (*model.Task, error)); ok {
		return rf(c, agentID, f)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, queue.FilterFn) *model.Task); ok {
		r0 = rf(c, agentID, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Task)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, queue.FilterFn) error); ok {
		r1 = rf(c, agentID, f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Push provides a mock function with given fields: c, task
func (_m *Queue) Push(c context.Context, task *model.Task) error {
	ret := _m.Called(c, task)

	if len(ret) == 0 {
		panic("no return value specified for Push")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Task) error); ok {
		r0 = rf(c, task)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PushAtOnce provides a mock function with given fields: c, tasks
func (_m *Queue) PushAtOnce(c context.Context, tasks []*model.Task) error {
	ret := _m.Called(c, tasks)

	if len(ret) == 0 {
		panic("no return value specified for PushAtOnce")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*model.Task) error); ok {
		r0 = rf(c, tasks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Resume provides a mock function with no fields
func (_m *Queue) Resume() {
	_m.Called()
}

// Wait provides a mock function with given fields: c, id
func (_m *Queue) Wait(c context.Context, id string) error {
	ret := _m.Called(c, id)

	if len(ret) == 0 {
		panic("no return value specified for Wait")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(c, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewQueue creates a new instance of Queue. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQueue(t interface {
	mock.TestingT
	Cleanup(func())
}) *Queue {
	mock := &Queue{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
