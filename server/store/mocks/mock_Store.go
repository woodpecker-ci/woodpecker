// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	mock "github.com/stretchr/testify/mock"
	"go.woodpecker-ci.org/woodpecker/v3/server/model"
)

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// AgentCreate provides a mock function for the type MockStore
func (_mock *MockStore) AgentCreate(agent *model.Agent) error {
	ret := _mock.Called(agent)

	if len(ret) == 0 {
		panic("no return value specified for AgentCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Agent) error); ok {
		r0 = returnFunc(agent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_AgentCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentCreate'
type MockStore_AgentCreate_Call struct {
	*mock.Call
}

// AgentCreate is a helper method to define mock.On call
//   - agent *model.Agent
func (_e *MockStore_Expecter) AgentCreate(agent interface{}) *MockStore_AgentCreate_Call {
	return &MockStore_AgentCreate_Call{Call: _e.mock.On("AgentCreate", agent)}
}

func (_c *MockStore_AgentCreate_Call) Run(run func(agent *model.Agent)) *MockStore_AgentCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Agent
		if args[0] != nil {
			arg0 = args[0].(*model.Agent)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_AgentCreate_Call) Return(err error) *MockStore_AgentCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_AgentCreate_Call) RunAndReturn(run func(agent *model.Agent) error) *MockStore_AgentCreate_Call {
	_c.Call.Return(run)
	return _c
}

// AgentDelete provides a mock function for the type MockStore
func (_mock *MockStore) AgentDelete(agent *model.Agent) error {
	ret := _mock.Called(agent)

	if len(ret) == 0 {
		panic("no return value specified for AgentDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Agent) error); ok {
		r0 = returnFunc(agent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_AgentDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentDelete'
type MockStore_AgentDelete_Call struct {
	*mock.Call
}

// AgentDelete is a helper method to define mock.On call
//   - agent *model.Agent
func (_e *MockStore_Expecter) AgentDelete(agent interface{}) *MockStore_AgentDelete_Call {
	return &MockStore_AgentDelete_Call{Call: _e.mock.On("AgentDelete", agent)}
}

func (_c *MockStore_AgentDelete_Call) Run(run func(agent *model.Agent)) *MockStore_AgentDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Agent
		if args[0] != nil {
			arg0 = args[0].(*model.Agent)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_AgentDelete_Call) Return(err error) *MockStore_AgentDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_AgentDelete_Call) RunAndReturn(run func(agent *model.Agent) error) *MockStore_AgentDelete_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFind provides a mock function for the type MockStore
func (_mock *MockStore) AgentFind(n int64) (*model.Agent, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for AgentFind")
	}

	var r0 *model.Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Agent, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Agent); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_AgentFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFind'
type MockStore_AgentFind_Call struct {
	*mock.Call
}

// AgentFind is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) AgentFind(n interface{}) *MockStore_AgentFind_Call {
	return &MockStore_AgentFind_Call{Call: _e.mock.On("AgentFind", n)}
}

func (_c *MockStore_AgentFind_Call) Run(run func(n int64)) *MockStore_AgentFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_AgentFind_Call) Return(agent *model.Agent, err error) *MockStore_AgentFind_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockStore_AgentFind_Call) RunAndReturn(run func(n int64) (*model.Agent, error)) *MockStore_AgentFind_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFindByToken provides a mock function for the type MockStore
func (_mock *MockStore) AgentFindByToken(s string) (*model.Agent, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for AgentFindByToken")
	}

	var r0 *model.Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*model.Agent, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *model.Agent); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_AgentFindByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFindByToken'
type MockStore_AgentFindByToken_Call struct {
	*mock.Call
}

// AgentFindByToken is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) AgentFindByToken(s interface{}) *MockStore_AgentFindByToken_Call {
	return &MockStore_AgentFindByToken_Call{Call: _e.mock.On("AgentFindByToken", s)}
}

func (_c *MockStore_AgentFindByToken_Call) Run(run func(s string)) *MockStore_AgentFindByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_AgentFindByToken_Call) Return(agent *model.Agent, err error) *MockStore_AgentFindByToken_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockStore_AgentFindByToken_Call) RunAndReturn(run func(s string) (*model.Agent, error)) *MockStore_AgentFindByToken_Call {
	_c.Call.Return(run)
	return _c
}

// AgentList provides a mock function for the type MockStore
func (_mock *MockStore) AgentList(p *model.ListOptions) ([]*model.Agent, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for AgentList")
	}

	var r0 []*model.Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) ([]*model.Agent, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) []*model.Agent); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.ListOptions) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_AgentList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentList'
type MockStore_AgentList_Call struct {
	*mock.Call
}

// AgentList is a helper method to define mock.On call
//   - p *model.ListOptions
func (_e *MockStore_Expecter) AgentList(p interface{}) *MockStore_AgentList_Call {
	return &MockStore_AgentList_Call{Call: _e.mock.On("AgentList", p)}
}

func (_c *MockStore_AgentList_Call) Run(run func(p *model.ListOptions)) *MockStore_AgentList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.ListOptions
		if args[0] != nil {
			arg0 = args[0].(*model.ListOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_AgentList_Call) Return(agents []*model.Agent, err error) *MockStore_AgentList_Call {
	_c.Call.Return(agents, err)
	return _c
}

func (_c *MockStore_AgentList_Call) RunAndReturn(run func(p *model.ListOptions) ([]*model.Agent, error)) *MockStore_AgentList_Call {
	_c.Call.Return(run)
	return _c
}

// AgentListForOrg provides a mock function for the type MockStore
func (_mock *MockStore) AgentListForOrg(orgID int64, opt *model.ListOptions) ([]*model.Agent, error) {
	ret := _mock.Called(orgID, opt)

	if len(ret) == 0 {
		panic("no return value specified for AgentListForOrg")
	}

	var r0 []*model.Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, *model.ListOptions) ([]*model.Agent, error)); ok {
		return returnFunc(orgID, opt)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, *model.ListOptions) []*model.Agent); ok {
		r0 = returnFunc(orgID, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, *model.ListOptions) error); ok {
		r1 = returnFunc(orgID, opt)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_AgentListForOrg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentListForOrg'
type MockStore_AgentListForOrg_Call struct {
	*mock.Call
}

// AgentListForOrg is a helper method to define mock.On call
//   - orgID int64
//   - opt *model.ListOptions
func (_e *MockStore_Expecter) AgentListForOrg(orgID interface{}, opt interface{}) *MockStore_AgentListForOrg_Call {
	return &MockStore_AgentListForOrg_Call{Call: _e.mock.On("AgentListForOrg", orgID, opt)}
}

func (_c *MockStore_AgentListForOrg_Call) Run(run func(orgID int64, opt *model.ListOptions)) *MockStore_AgentListForOrg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_AgentListForOrg_Call) Return(agents []*model.Agent, err error) *MockStore_AgentListForOrg_Call {
	_c.Call.Return(agents, err)
	return _c
}

func (_c *MockStore_AgentListForOrg_Call) RunAndReturn(run func(orgID int64, opt *model.ListOptions) ([]*model.Agent, error)) *MockStore_AgentListForOrg_Call {
	_c.Call.Return(run)
	return _c
}

// AgentUpdate provides a mock function for the type MockStore
func (_mock *MockStore) AgentUpdate(agent *model.Agent) error {
	ret := _mock.Called(agent)

	if len(ret) == 0 {
		panic("no return value specified for AgentUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Agent) error); ok {
		r0 = returnFunc(agent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_AgentUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentUpdate'
type MockStore_AgentUpdate_Call struct {
	*mock.Call
}

// AgentUpdate is a helper method to define mock.On call
//   - agent *model.Agent
func (_e *MockStore_Expecter) AgentUpdate(agent interface{}) *MockStore_AgentUpdate_Call {
	return &MockStore_AgentUpdate_Call{Call: _e.mock.On("AgentUpdate", agent)}
}

func (_c *MockStore_AgentUpdate_Call) Run(run func(agent *model.Agent)) *MockStore_AgentUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Agent
		if args[0] != nil {
			arg0 = args[0].(*model.Agent)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_AgentUpdate_Call) Return(err error) *MockStore_AgentUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_AgentUpdate_Call) RunAndReturn(run func(agent *model.Agent) error) *MockStore_AgentUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function for the type MockStore
func (_mock *MockStore) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockStore_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockStore_Expecter) Close() *MockStore_Close_Call {
	return &MockStore_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockStore_Close_Call) Run(run func()) *MockStore_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Close_Call) Return(err error) *MockStore_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_Close_Call) RunAndReturn(run func() error) *MockStore_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigPersist provides a mock function for the type MockStore
func (_mock *MockStore) ConfigPersist(config *model.Config) (*model.Config, error) {
	ret := _mock.Called(config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigPersist")
	}

	var r0 *model.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Config) (*model.Config, error)); ok {
		return returnFunc(config)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Config) *model.Config); ok {
		r0 = returnFunc(config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Config)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Config) error); ok {
		r1 = returnFunc(config)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ConfigPersist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigPersist'
type MockStore_ConfigPersist_Call struct {
	*mock.Call
}

// ConfigPersist is a helper method to define mock.On call
//   - config *model.Config
func (_e *MockStore_Expecter) ConfigPersist(config interface{}) *MockStore_ConfigPersist_Call {
	return &MockStore_ConfigPersist_Call{Call: _e.mock.On("ConfigPersist", config)}
}

func (_c *MockStore_ConfigPersist_Call) Run(run func(config *model.Config)) *MockStore_ConfigPersist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Config
		if args[0] != nil {
			arg0 = args[0].(*model.Config)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ConfigPersist_Call) Return(config1 *model.Config, err error) *MockStore_ConfigPersist_Call {
	_c.Call.Return(config1, err)
	return _c
}

func (_c *MockStore_ConfigPersist_Call) RunAndReturn(run func(config *model.Config) (*model.Config, error)) *MockStore_ConfigPersist_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigsForPipeline provides a mock function for the type MockStore
func (_mock *MockStore) ConfigsForPipeline(pipelineID int64) ([]*model.Config, error) {
	ret := _mock.Called(pipelineID)

	if len(ret) == 0 {
		panic("no return value specified for ConfigsForPipeline")
	}

	var r0 []*model.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) ([]*model.Config, error)); ok {
		return returnFunc(pipelineID)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) []*model.Config); ok {
		r0 = returnFunc(pipelineID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Config)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(pipelineID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ConfigsForPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigsForPipeline'
type MockStore_ConfigsForPipeline_Call struct {
	*mock.Call
}

// ConfigsForPipeline is a helper method to define mock.On call
//   - pipelineID int64
func (_e *MockStore_Expecter) ConfigsForPipeline(pipelineID interface{}) *MockStore_ConfigsForPipeline_Call {
	return &MockStore_ConfigsForPipeline_Call{Call: _e.mock.On("ConfigsForPipeline", pipelineID)}
}

func (_c *MockStore_ConfigsForPipeline_Call) Run(run func(pipelineID int64)) *MockStore_ConfigsForPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ConfigsForPipeline_Call) Return(configs []*model.Config, err error) *MockStore_ConfigsForPipeline_Call {
	_c.Call.Return(configs, err)
	return _c
}

func (_c *MockStore_ConfigsForPipeline_Call) RunAndReturn(run func(pipelineID int64) ([]*model.Config, error)) *MockStore_ConfigsForPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePipeline provides a mock function for the type MockStore
func (_mock *MockStore) CreatePipeline(pipeline *model.Pipeline, steps ...*model.Step) error {
	var tmpRet mock.Arguments
	if len(steps) > 0 {
		tmpRet = _mock.Called(pipeline, steps)
	} else {
		tmpRet = _mock.Called(pipeline)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreatePipeline")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline, ...*model.Step) error); ok {
		r0 = returnFunc(pipeline, steps...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreatePipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePipeline'
type MockStore_CreatePipeline_Call struct {
	*mock.Call
}

// CreatePipeline is a helper method to define mock.On call
//   - pipeline *model.Pipeline
//   - steps ...*model.Step
func (_e *MockStore_Expecter) CreatePipeline(pipeline interface{}, steps ...interface{}) *MockStore_CreatePipeline_Call {
	return &MockStore_CreatePipeline_Call{Call: _e.mock.On("CreatePipeline",
		append([]interface{}{pipeline}, steps...)...)}
}

func (_c *MockStore_CreatePipeline_Call) Run(run func(pipeline *model.Pipeline, steps ...*model.Step)) *MockStore_CreatePipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		var arg1 []*model.Step
		var variadicArgs []*model.Step
		if len(args) > 1 {
			variadicArgs = args[1].([]*model.Step)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockStore_CreatePipeline_Call) Return(err error) *MockStore_CreatePipeline_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreatePipeline_Call) RunAndReturn(run func(pipeline *model.Pipeline, steps ...*model.Step) error) *MockStore_CreatePipeline_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRedirection provides a mock function for the type MockStore
func (_mock *MockStore) CreateRedirection(redirection *model.Redirection) error {
	ret := _mock.Called(redirection)

	if len(ret) == 0 {
		panic("no return value specified for CreateRedirection")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Redirection) error); ok {
		r0 = returnFunc(redirection)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateRedirection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRedirection'
type MockStore_CreateRedirection_Call struct {
	*mock.Call
}

// CreateRedirection is a helper method to define mock.On call
//   - redirection *model.Redirection
func (_e *MockStore_Expecter) CreateRedirection(redirection interface{}) *MockStore_CreateRedirection_Call {
	return &MockStore_CreateRedirection_Call{Call: _e.mock.On("CreateRedirection", redirection)}
}

func (_c *MockStore_CreateRedirection_Call) Run(run func(redirection *model.Redirection)) *MockStore_CreateRedirection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Redirection
		if args[0] != nil {
			arg0 = args[0].(*model.Redirection)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_CreateRedirection_Call) Return(err error) *MockStore_CreateRedirection_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateRedirection_Call) RunAndReturn(run func(redirection *model.Redirection) error) *MockStore_CreateRedirection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepo provides a mock function for the type MockStore
func (_mock *MockStore) CreateRepo(repo *model.Repo) error {
	ret := _mock.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo) error); ok {
		r0 = returnFunc(repo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepo'
type MockStore_CreateRepo_Call struct {
	*mock.Call
}

// CreateRepo is a helper method to define mock.On call
//   - repo *model.Repo
func (_e *MockStore_Expecter) CreateRepo(repo interface{}) *MockStore_CreateRepo_Call {
	return &MockStore_CreateRepo_Call{Call: _e.mock.On("CreateRepo", repo)}
}

func (_c *MockStore_CreateRepo_Call) Run(run func(repo *model.Repo)) *MockStore_CreateRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_CreateRepo_Call) Return(err error) *MockStore_CreateRepo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateRepo_Call) RunAndReturn(run func(repo *model.Repo) error) *MockStore_CreateRepo_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function for the type MockStore
func (_mock *MockStore) CreateUser(user *model.User) error {
	ret := _mock.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.User) error); ok {
		r0 = returnFunc(user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockStore_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - user *model.User
func (_e *MockStore_Expecter) CreateUser(user interface{}) *MockStore_CreateUser_Call {
	return &MockStore_CreateUser_Call{Call: _e.mock.On("CreateUser", user)}
}

func (_c *MockStore_CreateUser_Call) Run(run func(user *model.User)) *MockStore_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_CreateUser_Call) Return(err error) *MockStore_CreateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateUser_Call) RunAndReturn(run func(user *model.User) error) *MockStore_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// CronCreate provides a mock function for the type MockStore
func (_mock *MockStore) CronCreate(cron *model.Cron) error {
	ret := _mock.Called(cron)

	if len(ret) == 0 {
		panic("no return value specified for CronCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Cron) error); ok {
		r0 = returnFunc(cron)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CronCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronCreate'
type MockStore_CronCreate_Call struct {
	*mock.Call
}

// CronCreate is a helper method to define mock.On call
//   - cron *model.Cron
func (_e *MockStore_Expecter) CronCreate(cron interface{}) *MockStore_CronCreate_Call {
	return &MockStore_CronCreate_Call{Call: _e.mock.On("CronCreate", cron)}
}

func (_c *MockStore_CronCreate_Call) Run(run func(cron *model.Cron)) *MockStore_CronCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Cron
		if args[0] != nil {
			arg0 = args[0].(*model.Cron)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_CronCreate_Call) Return(err error) *MockStore_CronCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CronCreate_Call) RunAndReturn(run func(cron *model.Cron) error) *MockStore_CronCreate_Call {
	_c.Call.Return(run)
	return _c
}

// CronDelete provides a mock function for the type MockStore
func (_mock *MockStore) CronDelete(repo *model.Repo, n int64) error {
	ret := _mock.Called(repo, n)

	if len(ret) == 0 {
		panic("no return value specified for CronDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, int64) error); ok {
		r0 = returnFunc(repo, n)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CronDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronDelete'
type MockStore_CronDelete_Call struct {
	*mock.Call
}

// CronDelete is a helper method to define mock.On call
//   - repo *model.Repo
//   - n int64
func (_e *MockStore_Expecter) CronDelete(repo interface{}, n interface{}) *MockStore_CronDelete_Call {
	return &MockStore_CronDelete_Call{Call: _e.mock.On("CronDelete", repo, n)}
}

func (_c *MockStore_CronDelete_Call) Run(run func(repo *model.Repo, n int64)) *MockStore_CronDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CronDelete_Call) Return(err error) *MockStore_CronDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CronDelete_Call) RunAndReturn(run func(repo *model.Repo, n int64) error) *MockStore_CronDelete_Call {
	_c.Call.Return(run)
	return _c
}

// CronFind provides a mock function for the type MockStore
func (_mock *MockStore) CronFind(repo *model.Repo, n int64) (*model.Cron, error) {
	ret := _mock.Called(repo, n)

	if len(ret) == 0 {
		panic("no return value specified for CronFind")
	}

	var r0 *model.Cron
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, int64) (*model.Cron, error)); ok {
		return returnFunc(repo, n)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, int64) *model.Cron); ok {
		r0 = returnFunc(repo, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Cron)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, int64) error); ok {
		r1 = returnFunc(repo, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CronFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronFind'
type MockStore_CronFind_Call struct {
	*mock.Call
}

// CronFind is a helper method to define mock.On call
//   - repo *model.Repo
//   - n int64
func (_e *MockStore_Expecter) CronFind(repo interface{}, n interface{}) *MockStore_CronFind_Call {
	return &MockStore_CronFind_Call{Call: _e.mock.On("CronFind", repo, n)}
}

func (_c *MockStore_CronFind_Call) Run(run func(repo *model.Repo, n int64)) *MockStore_CronFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CronFind_Call) Return(cron *model.Cron, err error) *MockStore_CronFind_Call {
	_c.Call.Return(cron, err)
	return _c
}

func (_c *MockStore_CronFind_Call) RunAndReturn(run func(repo *model.Repo, n int64) (*model.Cron, error)) *MockStore_CronFind_Call {
	_c.Call.Return(run)
	return _c
}

// CronGetLock provides a mock function for the type MockStore
func (_mock *MockStore) CronGetLock(cron *model.Cron, n int64) (bool, error) {
	ret := _mock.Called(cron, n)

	if len(ret) == 0 {
		panic("no return value specified for CronGetLock")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Cron, int64) (bool, error)); ok {
		return returnFunc(cron, n)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Cron, int64) bool); ok {
		r0 = returnFunc(cron, n)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Cron, int64) error); ok {
		r1 = returnFunc(cron, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CronGetLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronGetLock'
type MockStore_CronGetLock_Call struct {
	*mock.Call
}

// CronGetLock is a helper method to define mock.On call
//   - cron *model.Cron
//   - n int64
func (_e *MockStore_Expecter) CronGetLock(cron interface{}, n interface{}) *MockStore_CronGetLock_Call {
	return &MockStore_CronGetLock_Call{Call: _e.mock.On("CronGetLock", cron, n)}
}

func (_c *MockStore_CronGetLock_Call) Run(run func(cron *model.Cron, n int64)) *MockStore_CronGetLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Cron
		if args[0] != nil {
			arg0 = args[0].(*model.Cron)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CronGetLock_Call) Return(b bool, err error) *MockStore_CronGetLock_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_CronGetLock_Call) RunAndReturn(run func(cron *model.Cron, n int64) (bool, error)) *MockStore_CronGetLock_Call {
	_c.Call.Return(run)
	return _c
}

// CronList provides a mock function for the type MockStore
func (_mock *MockStore) CronList(repo *model.Repo, listOptions *model.ListOptions) ([]*model.Cron, error) {
	ret := _mock.Called(repo, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for CronList")
	}

	var r0 []*model.Cron
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, *model.ListOptions) ([]*model.Cron, error)); ok {
		return returnFunc(repo, listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, *model.ListOptions) []*model.Cron); ok {
		r0 = returnFunc(repo, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Cron)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, *model.ListOptions) error); ok {
		r1 = returnFunc(repo, listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CronList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronList'
type MockStore_CronList_Call struct {
	*mock.Call
}

// CronList is a helper method to define mock.On call
//   - repo *model.Repo
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) CronList(repo interface{}, listOptions interface{}) *MockStore_CronList_Call {
	return &MockStore_CronList_Call{Call: _e.mock.On("CronList", repo, listOptions)}
}

func (_c *MockStore_CronList_Call) Run(run func(repo *model.Repo, listOptions *model.ListOptions)) *MockStore_CronList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CronList_Call) Return(crons []*model.Cron, err error) *MockStore_CronList_Call {
	_c.Call.Return(crons, err)
	return _c
}

func (_c *MockStore_CronList_Call) RunAndReturn(run func(repo *model.Repo, listOptions *model.ListOptions) ([]*model.Cron, error)) *MockStore_CronList_Call {
	_c.Call.Return(run)
	return _c
}

// CronListNextExecute provides a mock function for the type MockStore
func (_mock *MockStore) CronListNextExecute(n int64, n1 int64) ([]*model.Cron, error) {
	ret := _mock.Called(n, n1)

	if len(ret) == 0 {
		panic("no return value specified for CronListNextExecute")
	}

	var r0 []*model.Cron
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int64) ([]*model.Cron, error)); ok {
		return returnFunc(n, n1)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int64) []*model.Cron); ok {
		r0 = returnFunc(n, n1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Cron)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int64) error); ok {
		r1 = returnFunc(n, n1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CronListNextExecute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronListNextExecute'
type MockStore_CronListNextExecute_Call struct {
	*mock.Call
}

// CronListNextExecute is a helper method to define mock.On call
//   - n int64
//   - n1 int64
func (_e *MockStore_Expecter) CronListNextExecute(n interface{}, n1 interface{}) *MockStore_CronListNextExecute_Call {
	return &MockStore_CronListNextExecute_Call{Call: _e.mock.On("CronListNextExecute", n, n1)}
}

func (_c *MockStore_CronListNextExecute_Call) Run(run func(n int64, n1 int64)) *MockStore_CronListNextExecute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CronListNextExecute_Call) Return(crons []*model.Cron, err error) *MockStore_CronListNextExecute_Call {
	_c.Call.Return(crons, err)
	return _c
}

func (_c *MockStore_CronListNextExecute_Call) RunAndReturn(run func(n int64, n1 int64) ([]*model.Cron, error)) *MockStore_CronListNextExecute_Call {
	_c.Call.Return(run)
	return _c
}

// CronUpdate provides a mock function for the type MockStore
func (_mock *MockStore) CronUpdate(repo *model.Repo, cron *model.Cron) error {
	ret := _mock.Called(repo, cron)

	if len(ret) == 0 {
		panic("no return value specified for CronUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, *model.Cron) error); ok {
		r0 = returnFunc(repo, cron)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CronUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronUpdate'
type MockStore_CronUpdate_Call struct {
	*mock.Call
}

// CronUpdate is a helper method to define mock.On call
//   - repo *model.Repo
//   - cron *model.Cron
func (_e *MockStore_Expecter) CronUpdate(repo interface{}, cron interface{}) *MockStore_CronUpdate_Call {
	return &MockStore_CronUpdate_Call{Call: _e.mock.On("CronUpdate", repo, cron)}
}

func (_c *MockStore_CronUpdate_Call) Run(run func(repo *model.Repo, cron *model.Cron)) *MockStore_CronUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 *model.Cron
		if args[1] != nil {
			arg1 = args[1].(*model.Cron)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CronUpdate_Call) Return(err error) *MockStore_CronUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CronUpdate_Call) RunAndReturn(run func(repo *model.Repo, cron *model.Cron) error) *MockStore_CronUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePipeline provides a mock function for the type MockStore
func (_mock *MockStore) DeletePipeline(pipeline *model.Pipeline) error {
	ret := _mock.Called(pipeline)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipeline")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline) error); ok {
		r0 = returnFunc(pipeline)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_DeletePipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePipeline'
type MockStore_DeletePipeline_Call struct {
	*mock.Call
}

// DeletePipeline is a helper method to define mock.On call
//   - pipeline *model.Pipeline
func (_e *MockStore_Expecter) DeletePipeline(pipeline interface{}) *MockStore_DeletePipeline_Call {
	return &MockStore_DeletePipeline_Call{Call: _e.mock.On("DeletePipeline", pipeline)}
}

func (_c *MockStore_DeletePipeline_Call) Run(run func(pipeline *model.Pipeline)) *MockStore_DeletePipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_DeletePipeline_Call) Return(err error) *MockStore_DeletePipeline_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_DeletePipeline_Call) RunAndReturn(run func(pipeline *model.Pipeline) error) *MockStore_DeletePipeline_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepo provides a mock function for the type MockStore
func (_mock *MockStore) DeleteRepo(repo *model.Repo) error {
	ret := _mock.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo) error); ok {
		r0 = returnFunc(repo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_DeleteRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepo'
type MockStore_DeleteRepo_Call struct {
	*mock.Call
}

// DeleteRepo is a helper method to define mock.On call
//   - repo *model.Repo
func (_e *MockStore_Expecter) DeleteRepo(repo interface{}) *MockStore_DeleteRepo_Call {
	return &MockStore_DeleteRepo_Call{Call: _e.mock.On("DeleteRepo", repo)}
}

func (_c *MockStore_DeleteRepo_Call) Run(run func(repo *model.Repo)) *MockStore_DeleteRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_DeleteRepo_Call) Return(err error) *MockStore_DeleteRepo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_DeleteRepo_Call) RunAndReturn(run func(repo *model.Repo) error) *MockStore_DeleteRepo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function for the type MockStore
func (_mock *MockStore) DeleteUser(user *model.User) error {
	ret := _mock.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.User) error); ok {
		r0 = returnFunc(user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockStore_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - user *model.User
func (_e *MockStore_Expecter) DeleteUser(user interface{}) *MockStore_DeleteUser_Call {
	return &MockStore_DeleteUser_Call{Call: _e.mock.On("DeleteUser", user)}
}

func (_c *MockStore_DeleteUser_Call) Run(run func(user *model.User)) *MockStore_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_DeleteUser_Call) Return(err error) *MockStore_DeleteUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_DeleteUser_Call) RunAndReturn(run func(user *model.User) error) *MockStore_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// ForgeCreate provides a mock function for the type MockStore
func (_mock *MockStore) ForgeCreate(forge *model.Forge) error {
	ret := _mock.Called(forge)

	if len(ret) == 0 {
		panic("no return value specified for ForgeCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Forge) error); ok {
		r0 = returnFunc(forge)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ForgeCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForgeCreate'
type MockStore_ForgeCreate_Call struct {
	*mock.Call
}

// ForgeCreate is a helper method to define mock.On call
//   - forge *model.Forge
func (_e *MockStore_Expecter) ForgeCreate(forge interface{}) *MockStore_ForgeCreate_Call {
	return &MockStore_ForgeCreate_Call{Call: _e.mock.On("ForgeCreate", forge)}
}

func (_c *MockStore_ForgeCreate_Call) Run(run func(forge *model.Forge)) *MockStore_ForgeCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Forge
		if args[0] != nil {
			arg0 = args[0].(*model.Forge)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ForgeCreate_Call) Return(err error) *MockStore_ForgeCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ForgeCreate_Call) RunAndReturn(run func(forge *model.Forge) error) *MockStore_ForgeCreate_Call {
	_c.Call.Return(run)
	return _c
}

// ForgeDelete provides a mock function for the type MockStore
func (_mock *MockStore) ForgeDelete(forge *model.Forge) error {
	ret := _mock.Called(forge)

	if len(ret) == 0 {
		panic("no return value specified for ForgeDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Forge) error); ok {
		r0 = returnFunc(forge)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ForgeDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForgeDelete'
type MockStore_ForgeDelete_Call struct {
	*mock.Call
}

// ForgeDelete is a helper method to define mock.On call
//   - forge *model.Forge
func (_e *MockStore_Expecter) ForgeDelete(forge interface{}) *MockStore_ForgeDelete_Call {
	return &MockStore_ForgeDelete_Call{Call: _e.mock.On("ForgeDelete", forge)}
}

func (_c *MockStore_ForgeDelete_Call) Run(run func(forge *model.Forge)) *MockStore_ForgeDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Forge
		if args[0] != nil {
			arg0 = args[0].(*model.Forge)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ForgeDelete_Call) Return(err error) *MockStore_ForgeDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ForgeDelete_Call) RunAndReturn(run func(forge *model.Forge) error) *MockStore_ForgeDelete_Call {
	_c.Call.Return(run)
	return _c
}

// ForgeGet provides a mock function for the type MockStore
func (_mock *MockStore) ForgeGet(n int64) (*model.Forge, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for ForgeGet")
	}

	var r0 *model.Forge
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Forge, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Forge); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Forge)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ForgeGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForgeGet'
type MockStore_ForgeGet_Call struct {
	*mock.Call
}

// ForgeGet is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) ForgeGet(n interface{}) *MockStore_ForgeGet_Call {
	return &MockStore_ForgeGet_Call{Call: _e.mock.On("ForgeGet", n)}
}

func (_c *MockStore_ForgeGet_Call) Run(run func(n int64)) *MockStore_ForgeGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ForgeGet_Call) Return(forge *model.Forge, err error) *MockStore_ForgeGet_Call {
	_c.Call.Return(forge, err)
	return _c
}

func (_c *MockStore_ForgeGet_Call) RunAndReturn(run func(n int64) (*model.Forge, error)) *MockStore_ForgeGet_Call {
	_c.Call.Return(run)
	return _c
}

// ForgeList provides a mock function for the type MockStore
func (_mock *MockStore) ForgeList(p *model.ListOptions) ([]*model.Forge, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for ForgeList")
	}

	var r0 []*model.Forge
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) ([]*model.Forge, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) []*model.Forge); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Forge)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.ListOptions) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ForgeList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForgeList'
type MockStore_ForgeList_Call struct {
	*mock.Call
}

// ForgeList is a helper method to define mock.On call
//   - p *model.ListOptions
func (_e *MockStore_Expecter) ForgeList(p interface{}) *MockStore_ForgeList_Call {
	return &MockStore_ForgeList_Call{Call: _e.mock.On("ForgeList", p)}
}

func (_c *MockStore_ForgeList_Call) Run(run func(p *model.ListOptions)) *MockStore_ForgeList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.ListOptions
		if args[0] != nil {
			arg0 = args[0].(*model.ListOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ForgeList_Call) Return(forges []*model.Forge, err error) *MockStore_ForgeList_Call {
	_c.Call.Return(forges, err)
	return _c
}

func (_c *MockStore_ForgeList_Call) RunAndReturn(run func(p *model.ListOptions) ([]*model.Forge, error)) *MockStore_ForgeList_Call {
	_c.Call.Return(run)
	return _c
}

// ForgeUpdate provides a mock function for the type MockStore
func (_mock *MockStore) ForgeUpdate(forge *model.Forge) error {
	ret := _mock.Called(forge)

	if len(ret) == 0 {
		panic("no return value specified for ForgeUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Forge) error); ok {
		r0 = returnFunc(forge)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ForgeUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForgeUpdate'
type MockStore_ForgeUpdate_Call struct {
	*mock.Call
}

// ForgeUpdate is a helper method to define mock.On call
//   - forge *model.Forge
func (_e *MockStore_Expecter) ForgeUpdate(forge interface{}) *MockStore_ForgeUpdate_Call {
	return &MockStore_ForgeUpdate_Call{Call: _e.mock.On("ForgeUpdate", forge)}
}

func (_c *MockStore_ForgeUpdate_Call) Run(run func(forge *model.Forge)) *MockStore_ForgeUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Forge
		if args[0] != nil {
			arg0 = args[0].(*model.Forge)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ForgeUpdate_Call) Return(err error) *MockStore_ForgeUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ForgeUpdate_Call) RunAndReturn(run func(forge *model.Forge) error) *MockStore_ForgeUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GetActivePipelineList provides a mock function for the type MockStore
func (_mock *MockStore) GetActivePipelineList(repo *model.Repo) ([]*model.Pipeline, error) {
	ret := _mock.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for GetActivePipelineList")
	}

	var r0 []*model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo) ([]*model.Pipeline, error)); ok {
		return returnFunc(repo)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo) []*model.Pipeline); ok {
		r0 = returnFunc(repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo) error); ok {
		r1 = returnFunc(repo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetActivePipelineList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActivePipelineList'
type MockStore_GetActivePipelineList_Call struct {
	*mock.Call
}

// GetActivePipelineList is a helper method to define mock.On call
//   - repo *model.Repo
func (_e *MockStore_Expecter) GetActivePipelineList(repo interface{}) *MockStore_GetActivePipelineList_Call {
	return &MockStore_GetActivePipelineList_Call{Call: _e.mock.On("GetActivePipelineList", repo)}
}

func (_c *MockStore_GetActivePipelineList_Call) Run(run func(repo *model.Repo)) *MockStore_GetActivePipelineList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetActivePipelineList_Call) Return(pipelines []*model.Pipeline, err error) *MockStore_GetActivePipelineList_Call {
	_c.Call.Return(pipelines, err)
	return _c
}

func (_c *MockStore_GetActivePipelineList_Call) RunAndReturn(run func(repo *model.Repo) ([]*model.Pipeline, error)) *MockStore_GetActivePipelineList_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipeline provides a mock function for the type MockStore
func (_mock *MockStore) GetPipeline(n int64) (*model.Pipeline, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for GetPipeline")
	}

	var r0 *model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Pipeline, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Pipeline); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipeline'
type MockStore_GetPipeline_Call struct {
	*mock.Call
}

// GetPipeline is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) GetPipeline(n interface{}) *MockStore_GetPipeline_Call {
	return &MockStore_GetPipeline_Call{Call: _e.mock.On("GetPipeline", n)}
}

func (_c *MockStore_GetPipeline_Call) Run(run func(n int64)) *MockStore_GetPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetPipeline_Call) Return(pipeline *model.Pipeline, err error) *MockStore_GetPipeline_Call {
	_c.Call.Return(pipeline, err)
	return _c
}

func (_c *MockStore_GetPipeline_Call) RunAndReturn(run func(n int64) (*model.Pipeline, error)) *MockStore_GetPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineBadge provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineBadge(repo *model.Repo, s string) (*model.Pipeline, error) {
	ret := _mock.Called(repo, s)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineBadge")
	}

	var r0 *model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) (*model.Pipeline, error)); ok {
		return returnFunc(repo, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) *model.Pipeline); ok {
		r0 = returnFunc(repo, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, string) error); ok {
		r1 = returnFunc(repo, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineBadge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineBadge'
type MockStore_GetPipelineBadge_Call struct {
	*mock.Call
}

// GetPipelineBadge is a helper method to define mock.On call
//   - repo *model.Repo
//   - s string
func (_e *MockStore_Expecter) GetPipelineBadge(repo interface{}, s interface{}) *MockStore_GetPipelineBadge_Call {
	return &MockStore_GetPipelineBadge_Call{Call: _e.mock.On("GetPipelineBadge", repo, s)}
}

func (_c *MockStore_GetPipelineBadge_Call) Run(run func(repo *model.Repo, s string)) *MockStore_GetPipelineBadge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetPipelineBadge_Call) Return(pipeline *model.Pipeline, err error) *MockStore_GetPipelineBadge_Call {
	_c.Call.Return(pipeline, err)
	return _c
}

func (_c *MockStore_GetPipelineBadge_Call) RunAndReturn(run func(repo *model.Repo, s string) (*model.Pipeline, error)) *MockStore_GetPipelineBadge_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineCount provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineCount() (int64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (int64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineCount'
type MockStore_GetPipelineCount_Call struct {
	*mock.Call
}

// GetPipelineCount is a helper method to define mock.On call
func (_e *MockStore_Expecter) GetPipelineCount() *MockStore_GetPipelineCount_Call {
	return &MockStore_GetPipelineCount_Call{Call: _e.mock.On("GetPipelineCount")}
}

func (_c *MockStore_GetPipelineCount_Call) Run(run func()) *MockStore_GetPipelineCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_GetPipelineCount_Call) Return(n int64, err error) *MockStore_GetPipelineCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetPipelineCount_Call) RunAndReturn(run func() (int64, error)) *MockStore_GetPipelineCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineLastBefore provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineLastBefore(repo *model.Repo, s string, n int64) (*model.Pipeline, error) {
	ret := _mock.Called(repo, s, n)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineLastBefore")
	}

	var r0 *model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string, int64) (*model.Pipeline, error)); ok {
		return returnFunc(repo, s, n)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string, int64) *model.Pipeline); ok {
		r0 = returnFunc(repo, s, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, string, int64) error); ok {
		r1 = returnFunc(repo, s, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineLastBefore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineLastBefore'
type MockStore_GetPipelineLastBefore_Call struct {
	*mock.Call
}

// GetPipelineLastBefore is a helper method to define mock.On call
//   - repo *model.Repo
//   - s string
//   - n int64
func (_e *MockStore_Expecter) GetPipelineLastBefore(repo interface{}, s interface{}, n interface{}) *MockStore_GetPipelineLastBefore_Call {
	return &MockStore_GetPipelineLastBefore_Call{Call: _e.mock.On("GetPipelineLastBefore", repo, s, n)}
}

func (_c *MockStore_GetPipelineLastBefore_Call) Run(run func(repo *model.Repo, s string, n int64)) *MockStore_GetPipelineLastBefore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_GetPipelineLastBefore_Call) Return(pipeline *model.Pipeline, err error) *MockStore_GetPipelineLastBefore_Call {
	_c.Call.Return(pipeline, err)
	return _c
}

func (_c *MockStore_GetPipelineLastBefore_Call) RunAndReturn(run func(repo *model.Repo, s string, n int64) (*model.Pipeline, error)) *MockStore_GetPipelineLastBefore_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineLastByBranch provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineLastByBranch(repo *model.Repo, s string) (*model.Pipeline, error) {
	ret := _mock.Called(repo, s)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineLastByBranch")
	}

	var r0 *model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) (*model.Pipeline, error)); ok {
		return returnFunc(repo, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) *model.Pipeline); ok {
		r0 = returnFunc(repo, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, string) error); ok {
		r1 = returnFunc(repo, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineLastByBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineLastByBranch'
type MockStore_GetPipelineLastByBranch_Call struct {
	*mock.Call
}

// GetPipelineLastByBranch is a helper method to define mock.On call
//   - repo *model.Repo
//   - s string
func (_e *MockStore_Expecter) GetPipelineLastByBranch(repo interface{}, s interface{}) *MockStore_GetPipelineLastByBranch_Call {
	return &MockStore_GetPipelineLastByBranch_Call{Call: _e.mock.On("GetPipelineLastByBranch", repo, s)}
}

func (_c *MockStore_GetPipelineLastByBranch_Call) Run(run func(repo *model.Repo, s string)) *MockStore_GetPipelineLastByBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetPipelineLastByBranch_Call) Return(pipeline *model.Pipeline, err error) *MockStore_GetPipelineLastByBranch_Call {
	_c.Call.Return(pipeline, err)
	return _c
}

func (_c *MockStore_GetPipelineLastByBranch_Call) RunAndReturn(run func(repo *model.Repo, s string) (*model.Pipeline, error)) *MockStore_GetPipelineLastByBranch_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineLastByPull provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineLastByPull(repo *model.Repo, s string) (*model.Pipeline, error) {
	ret := _mock.Called(repo, s)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineLastByPull")
	}

	var r0 *model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) (*model.Pipeline, error)); ok {
		return returnFunc(repo, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) *model.Pipeline); ok {
		r0 = returnFunc(repo, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, string) error); ok {
		r1 = returnFunc(repo, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineLastByPull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineLastByPull'
type MockStore_GetPipelineLastByPull_Call struct {
	*mock.Call
}

// GetPipelineLastByPull is a helper method to define mock.On call
//   - repo *model.Repo
//   - s string
func (_e *MockStore_Expecter) GetPipelineLastByPull(repo interface{}, s interface{}) *MockStore_GetPipelineLastByPull_Call {
	return &MockStore_GetPipelineLastByPull_Call{Call: _e.mock.On("GetPipelineLastByPull", repo, s)}
}

func (_c *MockStore_GetPipelineLastByPull_Call) Run(run func(repo *model.Repo, s string)) *MockStore_GetPipelineLastByPull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetPipelineLastByPull_Call) Return(pipeline *model.Pipeline, err error) *MockStore_GetPipelineLastByPull_Call {
	_c.Call.Return(pipeline, err)
	return _c
}

func (_c *MockStore_GetPipelineLastByPull_Call) RunAndReturn(run func(repo *model.Repo, s string) (*model.Pipeline, error)) *MockStore_GetPipelineLastByPull_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineList provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineList(repo *model.Repo, listOptions *model.ListOptions, pipelineFilter *model.PipelineFilter) ([]*model.Pipeline, error) {
	ret := _mock.Called(repo, listOptions, pipelineFilter)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineList")
	}

	var r0 []*model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, *model.ListOptions, *model.PipelineFilter) ([]*model.Pipeline, error)); ok {
		return returnFunc(repo, listOptions, pipelineFilter)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, *model.ListOptions, *model.PipelineFilter) []*model.Pipeline); ok {
		r0 = returnFunc(repo, listOptions, pipelineFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, *model.ListOptions, *model.PipelineFilter) error); ok {
		r1 = returnFunc(repo, listOptions, pipelineFilter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineList'
type MockStore_GetPipelineList_Call struct {
	*mock.Call
}

// GetPipelineList is a helper method to define mock.On call
//   - repo *model.Repo
//   - listOptions *model.ListOptions
//   - pipelineFilter *model.PipelineFilter
func (_e *MockStore_Expecter) GetPipelineList(repo interface{}, listOptions interface{}, pipelineFilter interface{}) *MockStore_GetPipelineList_Call {
	return &MockStore_GetPipelineList_Call{Call: _e.mock.On("GetPipelineList", repo, listOptions, pipelineFilter)}
}

func (_c *MockStore_GetPipelineList_Call) Run(run func(repo *model.Repo, listOptions *model.ListOptions, pipelineFilter *model.PipelineFilter)) *MockStore_GetPipelineList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		var arg2 *model.PipelineFilter
		if args[2] != nil {
			arg2 = args[2].(*model.PipelineFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_GetPipelineList_Call) Return(pipelines []*model.Pipeline, err error) *MockStore_GetPipelineList_Call {
	_c.Call.Return(pipelines, err)
	return _c
}

func (_c *MockStore_GetPipelineList_Call) RunAndReturn(run func(repo *model.Repo, listOptions *model.ListOptions, pipelineFilter *model.PipelineFilter) ([]*model.Pipeline, error)) *MockStore_GetPipelineList_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineNumber provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineNumber(repo *model.Repo, n int64) (*model.Pipeline, error) {
	ret := _mock.Called(repo, n)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineNumber")
	}

	var r0 *model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, int64) (*model.Pipeline, error)); ok {
		return returnFunc(repo, n)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, int64) *model.Pipeline); ok {
		r0 = returnFunc(repo, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, int64) error); ok {
		r1 = returnFunc(repo, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineNumber'
type MockStore_GetPipelineNumber_Call struct {
	*mock.Call
}

// GetPipelineNumber is a helper method to define mock.On call
//   - repo *model.Repo
//   - n int64
func (_e *MockStore_Expecter) GetPipelineNumber(repo interface{}, n interface{}) *MockStore_GetPipelineNumber_Call {
	return &MockStore_GetPipelineNumber_Call{Call: _e.mock.On("GetPipelineNumber", repo, n)}
}

func (_c *MockStore_GetPipelineNumber_Call) Run(run func(repo *model.Repo, n int64)) *MockStore_GetPipelineNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetPipelineNumber_Call) Return(pipeline *model.Pipeline, err error) *MockStore_GetPipelineNumber_Call {
	_c.Call.Return(pipeline, err)
	return _c
}

func (_c *MockStore_GetPipelineNumber_Call) RunAndReturn(run func(repo *model.Repo, n int64) (*model.Pipeline, error)) *MockStore_GetPipelineNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineQueue provides a mock function for the type MockStore
func (_mock *MockStore) GetPipelineQueue() ([]*model.Feed, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineQueue")
	}

	var r0 []*model.Feed
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]*model.Feed, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []*model.Feed); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Feed)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetPipelineQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineQueue'
type MockStore_GetPipelineQueue_Call struct {
	*mock.Call
}

// GetPipelineQueue is a helper method to define mock.On call
func (_e *MockStore_Expecter) GetPipelineQueue() *MockStore_GetPipelineQueue_Call {
	return &MockStore_GetPipelineQueue_Call{Call: _e.mock.On("GetPipelineQueue")}
}

func (_c *MockStore_GetPipelineQueue_Call) Run(run func()) *MockStore_GetPipelineQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_GetPipelineQueue_Call) Return(feeds []*model.Feed, err error) *MockStore_GetPipelineQueue_Call {
	_c.Call.Return(feeds, err)
	return _c
}

func (_c *MockStore_GetPipelineQueue_Call) RunAndReturn(run func() ([]*model.Feed, error)) *MockStore_GetPipelineQueue_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepo provides a mock function for the type MockStore
func (_mock *MockStore) GetRepo(n int64) (*model.Repo, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for GetRepo")
	}

	var r0 *model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Repo, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Repo); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepo'
type MockStore_GetRepo_Call struct {
	*mock.Call
}

// GetRepo is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) GetRepo(n interface{}) *MockStore_GetRepo_Call {
	return &MockStore_GetRepo_Call{Call: _e.mock.On("GetRepo", n)}
}

func (_c *MockStore_GetRepo_Call) Run(run func(n int64)) *MockStore_GetRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetRepo_Call) Return(repo *model.Repo, err error) *MockStore_GetRepo_Call {
	_c.Call.Return(repo, err)
	return _c
}

func (_c *MockStore_GetRepo_Call) RunAndReturn(run func(n int64) (*model.Repo, error)) *MockStore_GetRepo_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoCount provides a mock function for the type MockStore
func (_mock *MockStore) GetRepoCount() (int64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRepoCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (int64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetRepoCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoCount'
type MockStore_GetRepoCount_Call struct {
	*mock.Call
}

// GetRepoCount is a helper method to define mock.On call
func (_e *MockStore_Expecter) GetRepoCount() *MockStore_GetRepoCount_Call {
	return &MockStore_GetRepoCount_Call{Call: _e.mock.On("GetRepoCount")}
}

func (_c *MockStore_GetRepoCount_Call) Run(run func()) *MockStore_GetRepoCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_GetRepoCount_Call) Return(n int64, err error) *MockStore_GetRepoCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetRepoCount_Call) RunAndReturn(run func() (int64, error)) *MockStore_GetRepoCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoForgeID provides a mock function for the type MockStore
func (_mock *MockStore) GetRepoForgeID(forgeRemoteID model.ForgeRemoteID) (*model.Repo, error) {
	ret := _mock.Called(forgeRemoteID)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoForgeID")
	}

	var r0 *model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(model.ForgeRemoteID) (*model.Repo, error)); ok {
		return returnFunc(forgeRemoteID)
	}
	if returnFunc, ok := ret.Get(0).(func(model.ForgeRemoteID) *model.Repo); ok {
		r0 = returnFunc(forgeRemoteID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(model.ForgeRemoteID) error); ok {
		r1 = returnFunc(forgeRemoteID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetRepoForgeID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoForgeID'
type MockStore_GetRepoForgeID_Call struct {
	*mock.Call
}

// GetRepoForgeID is a helper method to define mock.On call
//   - forgeRemoteID model.ForgeRemoteID
func (_e *MockStore_Expecter) GetRepoForgeID(forgeRemoteID interface{}) *MockStore_GetRepoForgeID_Call {
	return &MockStore_GetRepoForgeID_Call{Call: _e.mock.On("GetRepoForgeID", forgeRemoteID)}
}

func (_c *MockStore_GetRepoForgeID_Call) Run(run func(forgeRemoteID model.ForgeRemoteID)) *MockStore_GetRepoForgeID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.ForgeRemoteID
		if args[0] != nil {
			arg0 = args[0].(model.ForgeRemoteID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetRepoForgeID_Call) Return(repo *model.Repo, err error) *MockStore_GetRepoForgeID_Call {
	_c.Call.Return(repo, err)
	return _c
}

func (_c *MockStore_GetRepoForgeID_Call) RunAndReturn(run func(forgeRemoteID model.ForgeRemoteID) (*model.Repo, error)) *MockStore_GetRepoForgeID_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoLatestPipelines provides a mock function for the type MockStore
func (_mock *MockStore) GetRepoLatestPipelines(int64s []int64) ([]*model.Pipeline, error) {
	ret := _mock.Called(int64s)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoLatestPipelines")
	}

	var r0 []*model.Pipeline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]int64) ([]*model.Pipeline, error)); ok {
		return returnFunc(int64s)
	}
	if returnFunc, ok := ret.Get(0).(func([]int64) []*model.Pipeline); ok {
		r0 = returnFunc(int64s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Pipeline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]int64) error); ok {
		r1 = returnFunc(int64s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetRepoLatestPipelines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoLatestPipelines'
type MockStore_GetRepoLatestPipelines_Call struct {
	*mock.Call
}

// GetRepoLatestPipelines is a helper method to define mock.On call
//   - int64s []int64
func (_e *MockStore_Expecter) GetRepoLatestPipelines(int64s interface{}) *MockStore_GetRepoLatestPipelines_Call {
	return &MockStore_GetRepoLatestPipelines_Call{Call: _e.mock.On("GetRepoLatestPipelines", int64s)}
}

func (_c *MockStore_GetRepoLatestPipelines_Call) Run(run func(int64s []int64)) *MockStore_GetRepoLatestPipelines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []int64
		if args[0] != nil {
			arg0 = args[0].([]int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetRepoLatestPipelines_Call) Return(pipelines []*model.Pipeline, err error) *MockStore_GetRepoLatestPipelines_Call {
	_c.Call.Return(pipelines, err)
	return _c
}

func (_c *MockStore_GetRepoLatestPipelines_Call) RunAndReturn(run func(int64s []int64) ([]*model.Pipeline, error)) *MockStore_GetRepoLatestPipelines_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoName provides a mock function for the type MockStore
func (_mock *MockStore) GetRepoName(s string) (*model.Repo, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoName")
	}

	var r0 *model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*model.Repo, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *model.Repo); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetRepoName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoName'
type MockStore_GetRepoName_Call struct {
	*mock.Call
}

// GetRepoName is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) GetRepoName(s interface{}) *MockStore_GetRepoName_Call {
	return &MockStore_GetRepoName_Call{Call: _e.mock.On("GetRepoName", s)}
}

func (_c *MockStore_GetRepoName_Call) Run(run func(s string)) *MockStore_GetRepoName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetRepoName_Call) Return(repo *model.Repo, err error) *MockStore_GetRepoName_Call {
	_c.Call.Return(repo, err)
	return _c
}

func (_c *MockStore_GetRepoName_Call) RunAndReturn(run func(s string) (*model.Repo, error)) *MockStore_GetRepoName_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoNameFallback provides a mock function for the type MockStore
func (_mock *MockStore) GetRepoNameFallback(remoteID model.ForgeRemoteID, fullName string) (*model.Repo, error) {
	ret := _mock.Called(remoteID, fullName)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoNameFallback")
	}

	var r0 *model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(model.ForgeRemoteID, string) (*model.Repo, error)); ok {
		return returnFunc(remoteID, fullName)
	}
	if returnFunc, ok := ret.Get(0).(func(model.ForgeRemoteID, string) *model.Repo); ok {
		r0 = returnFunc(remoteID, fullName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(model.ForgeRemoteID, string) error); ok {
		r1 = returnFunc(remoteID, fullName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetRepoNameFallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoNameFallback'
type MockStore_GetRepoNameFallback_Call struct {
	*mock.Call
}

// GetRepoNameFallback is a helper method to define mock.On call
//   - remoteID model.ForgeRemoteID
//   - fullName string
func (_e *MockStore_Expecter) GetRepoNameFallback(remoteID interface{}, fullName interface{}) *MockStore_GetRepoNameFallback_Call {
	return &MockStore_GetRepoNameFallback_Call{Call: _e.mock.On("GetRepoNameFallback", remoteID, fullName)}
}

func (_c *MockStore_GetRepoNameFallback_Call) Run(run func(remoteID model.ForgeRemoteID, fullName string)) *MockStore_GetRepoNameFallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.ForgeRemoteID
		if args[0] != nil {
			arg0 = args[0].(model.ForgeRemoteID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetRepoNameFallback_Call) Return(repo *model.Repo, err error) *MockStore_GetRepoNameFallback_Call {
	_c.Call.Return(repo, err)
	return _c
}

func (_c *MockStore_GetRepoNameFallback_Call) RunAndReturn(run func(remoteID model.ForgeRemoteID, fullName string) (*model.Repo, error)) *MockStore_GetRepoNameFallback_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function for the type MockStore
func (_mock *MockStore) GetUser(n int64) (*model.User, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *model.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.User, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.User); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type MockStore_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) GetUser(n interface{}) *MockStore_GetUser_Call {
	return &MockStore_GetUser_Call{Call: _e.mock.On("GetUser", n)}
}

func (_c *MockStore_GetUser_Call) Run(run func(n int64)) *MockStore_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetUser_Call) Return(user *model.User, err error) *MockStore_GetUser_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockStore_GetUser_Call) RunAndReturn(run func(n int64) (*model.User, error)) *MockStore_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserCount provides a mock function for the type MockStore
func (_mock *MockStore) GetUserCount() (int64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetUserCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (int64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserCount'
type MockStore_GetUserCount_Call struct {
	*mock.Call
}

// GetUserCount is a helper method to define mock.On call
func (_e *MockStore_Expecter) GetUserCount() *MockStore_GetUserCount_Call {
	return &MockStore_GetUserCount_Call{Call: _e.mock.On("GetUserCount")}
}

func (_c *MockStore_GetUserCount_Call) Run(run func()) *MockStore_GetUserCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_GetUserCount_Call) Return(n int64, err error) *MockStore_GetUserCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetUserCount_Call) RunAndReturn(run func() (int64, error)) *MockStore_GetUserCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserList provides a mock function for the type MockStore
func (_mock *MockStore) GetUserList(p *model.ListOptions) ([]*model.User, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for GetUserList")
	}

	var r0 []*model.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) ([]*model.User, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) []*model.User); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.ListOptions) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserList'
type MockStore_GetUserList_Call struct {
	*mock.Call
}

// GetUserList is a helper method to define mock.On call
//   - p *model.ListOptions
func (_e *MockStore_Expecter) GetUserList(p interface{}) *MockStore_GetUserList_Call {
	return &MockStore_GetUserList_Call{Call: _e.mock.On("GetUserList", p)}
}

func (_c *MockStore_GetUserList_Call) Run(run func(p *model.ListOptions)) *MockStore_GetUserList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.ListOptions
		if args[0] != nil {
			arg0 = args[0].(*model.ListOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetUserList_Call) Return(users []*model.User, err error) *MockStore_GetUserList_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockStore_GetUserList_Call) RunAndReturn(run func(p *model.ListOptions) ([]*model.User, error)) *MockStore_GetUserList_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserLogin provides a mock function for the type MockStore
func (_mock *MockStore) GetUserLogin(s string) (*model.User, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for GetUserLogin")
	}

	var r0 *model.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*model.User, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *model.User); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserLogin'
type MockStore_GetUserLogin_Call struct {
	*mock.Call
}

// GetUserLogin is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) GetUserLogin(s interface{}) *MockStore_GetUserLogin_Call {
	return &MockStore_GetUserLogin_Call{Call: _e.mock.On("GetUserLogin", s)}
}

func (_c *MockStore_GetUserLogin_Call) Run(run func(s string)) *MockStore_GetUserLogin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetUserLogin_Call) Return(user *model.User, err error) *MockStore_GetUserLogin_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockStore_GetUserLogin_Call) RunAndReturn(run func(s string) (*model.User, error)) *MockStore_GetUserLogin_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserRemoteID provides a mock function for the type MockStore
func (_mock *MockStore) GetUserRemoteID(forgeRemoteID model.ForgeRemoteID, s string) (*model.User, error) {
	ret := _mock.Called(forgeRemoteID, s)

	if len(ret) == 0 {
		panic("no return value specified for GetUserRemoteID")
	}

	var r0 *model.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(model.ForgeRemoteID, string) (*model.User, error)); ok {
		return returnFunc(forgeRemoteID, s)
	}
	if returnFunc, ok := ret.Get(0).(func(model.ForgeRemoteID, string) *model.User); ok {
		r0 = returnFunc(forgeRemoteID, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(model.ForgeRemoteID, string) error); ok {
		r1 = returnFunc(forgeRemoteID, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetUserRemoteID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserRemoteID'
type MockStore_GetUserRemoteID_Call struct {
	*mock.Call
}

// GetUserRemoteID is a helper method to define mock.On call
//   - forgeRemoteID model.ForgeRemoteID
//   - s string
func (_e *MockStore_Expecter) GetUserRemoteID(forgeRemoteID interface{}, s interface{}) *MockStore_GetUserRemoteID_Call {
	return &MockStore_GetUserRemoteID_Call{Call: _e.mock.On("GetUserRemoteID", forgeRemoteID, s)}
}

func (_c *MockStore_GetUserRemoteID_Call) Run(run func(forgeRemoteID model.ForgeRemoteID, s string)) *MockStore_GetUserRemoteID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.ForgeRemoteID
		if args[0] != nil {
			arg0 = args[0].(model.ForgeRemoteID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetUserRemoteID_Call) Return(user *model.User, err error) *MockStore_GetUserRemoteID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockStore_GetUserRemoteID_Call) RunAndReturn(run func(forgeRemoteID model.ForgeRemoteID, s string) (*model.User, error)) *MockStore_GetUserRemoteID_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalRegistryFind provides a mock function for the type MockStore
func (_mock *MockStore) GlobalRegistryFind(s string) (*model.Registry, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for GlobalRegistryFind")
	}

	var r0 *model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*model.Registry, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *model.Registry); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GlobalRegistryFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalRegistryFind'
type MockStore_GlobalRegistryFind_Call struct {
	*mock.Call
}

// GlobalRegistryFind is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) GlobalRegistryFind(s interface{}) *MockStore_GlobalRegistryFind_Call {
	return &MockStore_GlobalRegistryFind_Call{Call: _e.mock.On("GlobalRegistryFind", s)}
}

func (_c *MockStore_GlobalRegistryFind_Call) Run(run func(s string)) *MockStore_GlobalRegistryFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GlobalRegistryFind_Call) Return(registry *model.Registry, err error) *MockStore_GlobalRegistryFind_Call {
	_c.Call.Return(registry, err)
	return _c
}

func (_c *MockStore_GlobalRegistryFind_Call) RunAndReturn(run func(s string) (*model.Registry, error)) *MockStore_GlobalRegistryFind_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalRegistryList provides a mock function for the type MockStore
func (_mock *MockStore) GlobalRegistryList(listOptions *model.ListOptions) ([]*model.Registry, error) {
	ret := _mock.Called(listOptions)

	if len(ret) == 0 {
		panic("no return value specified for GlobalRegistryList")
	}

	var r0 []*model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) ([]*model.Registry, error)); ok {
		return returnFunc(listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) []*model.Registry); ok {
		r0 = returnFunc(listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.ListOptions) error); ok {
		r1 = returnFunc(listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GlobalRegistryList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalRegistryList'
type MockStore_GlobalRegistryList_Call struct {
	*mock.Call
}

// GlobalRegistryList is a helper method to define mock.On call
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) GlobalRegistryList(listOptions interface{}) *MockStore_GlobalRegistryList_Call {
	return &MockStore_GlobalRegistryList_Call{Call: _e.mock.On("GlobalRegistryList", listOptions)}
}

func (_c *MockStore_GlobalRegistryList_Call) Run(run func(listOptions *model.ListOptions)) *MockStore_GlobalRegistryList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.ListOptions
		if args[0] != nil {
			arg0 = args[0].(*model.ListOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GlobalRegistryList_Call) Return(registrys []*model.Registry, err error) *MockStore_GlobalRegistryList_Call {
	_c.Call.Return(registrys, err)
	return _c
}

func (_c *MockStore_GlobalRegistryList_Call) RunAndReturn(run func(listOptions *model.ListOptions) ([]*model.Registry, error)) *MockStore_GlobalRegistryList_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalSecretFind provides a mock function for the type MockStore
func (_mock *MockStore) GlobalSecretFind(s string) (*model.Secret, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for GlobalSecretFind")
	}

	var r0 *model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*model.Secret, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *model.Secret); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GlobalSecretFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalSecretFind'
type MockStore_GlobalSecretFind_Call struct {
	*mock.Call
}

// GlobalSecretFind is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) GlobalSecretFind(s interface{}) *MockStore_GlobalSecretFind_Call {
	return &MockStore_GlobalSecretFind_Call{Call: _e.mock.On("GlobalSecretFind", s)}
}

func (_c *MockStore_GlobalSecretFind_Call) Run(run func(s string)) *MockStore_GlobalSecretFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GlobalSecretFind_Call) Return(secret *model.Secret, err error) *MockStore_GlobalSecretFind_Call {
	_c.Call.Return(secret, err)
	return _c
}

func (_c *MockStore_GlobalSecretFind_Call) RunAndReturn(run func(s string) (*model.Secret, error)) *MockStore_GlobalSecretFind_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalSecretList provides a mock function for the type MockStore
func (_mock *MockStore) GlobalSecretList(listOptions *model.ListOptions) ([]*model.Secret, error) {
	ret := _mock.Called(listOptions)

	if len(ret) == 0 {
		panic("no return value specified for GlobalSecretList")
	}

	var r0 []*model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) ([]*model.Secret, error)); ok {
		return returnFunc(listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) []*model.Secret); ok {
		r0 = returnFunc(listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.ListOptions) error); ok {
		r1 = returnFunc(listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GlobalSecretList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalSecretList'
type MockStore_GlobalSecretList_Call struct {
	*mock.Call
}

// GlobalSecretList is a helper method to define mock.On call
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) GlobalSecretList(listOptions interface{}) *MockStore_GlobalSecretList_Call {
	return &MockStore_GlobalSecretList_Call{Call: _e.mock.On("GlobalSecretList", listOptions)}
}

func (_c *MockStore_GlobalSecretList_Call) Run(run func(listOptions *model.ListOptions)) *MockStore_GlobalSecretList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.ListOptions
		if args[0] != nil {
			arg0 = args[0].(*model.ListOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GlobalSecretList_Call) Return(secrets []*model.Secret, err error) *MockStore_GlobalSecretList_Call {
	_c.Call.Return(secrets, err)
	return _c
}

func (_c *MockStore_GlobalSecretList_Call) RunAndReturn(run func(listOptions *model.ListOptions) ([]*model.Secret, error)) *MockStore_GlobalSecretList_Call {
	_c.Call.Return(run)
	return _c
}

// HasRedirectionForRepo provides a mock function for the type MockStore
func (_mock *MockStore) HasRedirectionForRepo(n int64, s string) (bool, error) {
	ret := _mock.Called(n, s)

	if len(ret) == 0 {
		panic("no return value specified for HasRedirectionForRepo")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, string) (bool, error)); ok {
		return returnFunc(n, s)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, string) bool); ok {
		r0 = returnFunc(n, s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, string) error); ok {
		r1 = returnFunc(n, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_HasRedirectionForRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasRedirectionForRepo'
type MockStore_HasRedirectionForRepo_Call struct {
	*mock.Call
}

// HasRedirectionForRepo is a helper method to define mock.On call
//   - n int64
//   - s string
func (_e *MockStore_Expecter) HasRedirectionForRepo(n interface{}, s interface{}) *MockStore_HasRedirectionForRepo_Call {
	return &MockStore_HasRedirectionForRepo_Call{Call: _e.mock.On("HasRedirectionForRepo", n, s)}
}

func (_c *MockStore_HasRedirectionForRepo_Call) Run(run func(n int64, s string)) *MockStore_HasRedirectionForRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_HasRedirectionForRepo_Call) Return(b bool, err error) *MockStore_HasRedirectionForRepo_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_HasRedirectionForRepo_Call) RunAndReturn(run func(n int64, s string) (bool, error)) *MockStore_HasRedirectionForRepo_Call {
	_c.Call.Return(run)
	return _c
}

// LogAppend provides a mock function for the type MockStore
func (_mock *MockStore) LogAppend(step *model.Step, logEntrys []*model.LogEntry) error {
	ret := _mock.Called(step, logEntrys)

	if len(ret) == 0 {
		panic("no return value specified for LogAppend")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Step, []*model.LogEntry) error); ok {
		r0 = returnFunc(step, logEntrys)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_LogAppend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogAppend'
type MockStore_LogAppend_Call struct {
	*mock.Call
}

// LogAppend is a helper method to define mock.On call
//   - step *model.Step
//   - logEntrys []*model.LogEntry
func (_e *MockStore_Expecter) LogAppend(step interface{}, logEntrys interface{}) *MockStore_LogAppend_Call {
	return &MockStore_LogAppend_Call{Call: _e.mock.On("LogAppend", step, logEntrys)}
}

func (_c *MockStore_LogAppend_Call) Run(run func(step *model.Step, logEntrys []*model.LogEntry)) *MockStore_LogAppend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Step
		if args[0] != nil {
			arg0 = args[0].(*model.Step)
		}
		var arg1 []*model.LogEntry
		if args[1] != nil {
			arg1 = args[1].([]*model.LogEntry)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_LogAppend_Call) Return(err error) *MockStore_LogAppend_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_LogAppend_Call) RunAndReturn(run func(step *model.Step, logEntrys []*model.LogEntry) error) *MockStore_LogAppend_Call {
	_c.Call.Return(run)
	return _c
}

// LogDelete provides a mock function for the type MockStore
func (_mock *MockStore) LogDelete(step *model.Step) error {
	ret := _mock.Called(step)

	if len(ret) == 0 {
		panic("no return value specified for LogDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Step) error); ok {
		r0 = returnFunc(step)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_LogDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogDelete'
type MockStore_LogDelete_Call struct {
	*mock.Call
}

// LogDelete is a helper method to define mock.On call
//   - step *model.Step
func (_e *MockStore_Expecter) LogDelete(step interface{}) *MockStore_LogDelete_Call {
	return &MockStore_LogDelete_Call{Call: _e.mock.On("LogDelete", step)}
}

func (_c *MockStore_LogDelete_Call) Run(run func(step *model.Step)) *MockStore_LogDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Step
		if args[0] != nil {
			arg0 = args[0].(*model.Step)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_LogDelete_Call) Return(err error) *MockStore_LogDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_LogDelete_Call) RunAndReturn(run func(step *model.Step) error) *MockStore_LogDelete_Call {
	_c.Call.Return(run)
	return _c
}

// LogFind provides a mock function for the type MockStore
func (_mock *MockStore) LogFind(step *model.Step) ([]*model.LogEntry, error) {
	ret := _mock.Called(step)

	if len(ret) == 0 {
		panic("no return value specified for LogFind")
	}

	var r0 []*model.LogEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Step) ([]*model.LogEntry, error)); ok {
		return returnFunc(step)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Step) []*model.LogEntry); ok {
		r0 = returnFunc(step)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.LogEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Step) error); ok {
		r1 = returnFunc(step)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_LogFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogFind'
type MockStore_LogFind_Call struct {
	*mock.Call
}

// LogFind is a helper method to define mock.On call
//   - step *model.Step
func (_e *MockStore_Expecter) LogFind(step interface{}) *MockStore_LogFind_Call {
	return &MockStore_LogFind_Call{Call: _e.mock.On("LogFind", step)}
}

func (_c *MockStore_LogFind_Call) Run(run func(step *model.Step)) *MockStore_LogFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Step
		if args[0] != nil {
			arg0 = args[0].(*model.Step)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_LogFind_Call) Return(logEntrys []*model.LogEntry, err error) *MockStore_LogFind_Call {
	_c.Call.Return(logEntrys, err)
	return _c
}

func (_c *MockStore_LogFind_Call) RunAndReturn(run func(step *model.Step) ([]*model.LogEntry, error)) *MockStore_LogFind_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function for the type MockStore
func (_mock *MockStore) Migrate(context1 context.Context, b bool) error {
	ret := _mock.Called(context1, b)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) error); ok {
		r0 = returnFunc(context1, b)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockStore_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - context1 context.Context
//   - b bool
func (_e *MockStore_Expecter) Migrate(context1 interface{}, b interface{}) *MockStore_Migrate_Call {
	return &MockStore_Migrate_Call{Call: _e.mock.On("Migrate", context1, b)}
}

func (_c *MockStore_Migrate_Call) Run(run func(context1 context.Context, b bool)) *MockStore_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_Migrate_Call) Return(err error) *MockStore_Migrate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_Migrate_Call) RunAndReturn(run func(context1 context.Context, b bool) error) *MockStore_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// OrgCreate provides a mock function for the type MockStore
func (_mock *MockStore) OrgCreate(org *model.Org) error {
	ret := _mock.Called(org)

	if len(ret) == 0 {
		panic("no return value specified for OrgCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Org) error); ok {
		r0 = returnFunc(org)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_OrgCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgCreate'
type MockStore_OrgCreate_Call struct {
	*mock.Call
}

// OrgCreate is a helper method to define mock.On call
//   - org *model.Org
func (_e *MockStore_Expecter) OrgCreate(org interface{}) *MockStore_OrgCreate_Call {
	return &MockStore_OrgCreate_Call{Call: _e.mock.On("OrgCreate", org)}
}

func (_c *MockStore_OrgCreate_Call) Run(run func(org *model.Org)) *MockStore_OrgCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Org
		if args[0] != nil {
			arg0 = args[0].(*model.Org)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_OrgCreate_Call) Return(err error) *MockStore_OrgCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_OrgCreate_Call) RunAndReturn(run func(org *model.Org) error) *MockStore_OrgCreate_Call {
	_c.Call.Return(run)
	return _c
}

// OrgDelete provides a mock function for the type MockStore
func (_mock *MockStore) OrgDelete(n int64) error {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for OrgDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int64) error); ok {
		r0 = returnFunc(n)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_OrgDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgDelete'
type MockStore_OrgDelete_Call struct {
	*mock.Call
}

// OrgDelete is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) OrgDelete(n interface{}) *MockStore_OrgDelete_Call {
	return &MockStore_OrgDelete_Call{Call: _e.mock.On("OrgDelete", n)}
}

func (_c *MockStore_OrgDelete_Call) Run(run func(n int64)) *MockStore_OrgDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_OrgDelete_Call) Return(err error) *MockStore_OrgDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_OrgDelete_Call) RunAndReturn(run func(n int64) error) *MockStore_OrgDelete_Call {
	_c.Call.Return(run)
	return _c
}

// OrgFindByName provides a mock function for the type MockStore
func (_mock *MockStore) OrgFindByName(s string, n int64) (*model.Org, error) {
	ret := _mock.Called(s, n)

	if len(ret) == 0 {
		panic("no return value specified for OrgFindByName")
	}

	var r0 *model.Org
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, int64) (*model.Org, error)); ok {
		return returnFunc(s, n)
	}
	if returnFunc, ok := ret.Get(0).(func(string, int64) *model.Org); ok {
		r0 = returnFunc(s, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Org)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = returnFunc(s, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgFindByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgFindByName'
type MockStore_OrgFindByName_Call struct {
	*mock.Call
}

// OrgFindByName is a helper method to define mock.On call
//   - s string
//   - n int64
func (_e *MockStore_Expecter) OrgFindByName(s interface{}, n interface{}) *MockStore_OrgFindByName_Call {
	return &MockStore_OrgFindByName_Call{Call: _e.mock.On("OrgFindByName", s, n)}
}

func (_c *MockStore_OrgFindByName_Call) Run(run func(s string, n int64)) *MockStore_OrgFindByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_OrgFindByName_Call) Return(org *model.Org, err error) *MockStore_OrgFindByName_Call {
	_c.Call.Return(org, err)
	return _c
}

func (_c *MockStore_OrgFindByName_Call) RunAndReturn(run func(s string, n int64) (*model.Org, error)) *MockStore_OrgFindByName_Call {
	_c.Call.Return(run)
	return _c
}

// OrgGet provides a mock function for the type MockStore
func (_mock *MockStore) OrgGet(n int64) (*model.Org, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for OrgGet")
	}

	var r0 *model.Org
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Org, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Org); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Org)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgGet'
type MockStore_OrgGet_Call struct {
	*mock.Call
}

// OrgGet is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) OrgGet(n interface{}) *MockStore_OrgGet_Call {
	return &MockStore_OrgGet_Call{Call: _e.mock.On("OrgGet", n)}
}

func (_c *MockStore_OrgGet_Call) Run(run func(n int64)) *MockStore_OrgGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_OrgGet_Call) Return(org *model.Org, err error) *MockStore_OrgGet_Call {
	_c.Call.Return(org, err)
	return _c
}

func (_c *MockStore_OrgGet_Call) RunAndReturn(run func(n int64) (*model.Org, error)) *MockStore_OrgGet_Call {
	_c.Call.Return(run)
	return _c
}

// OrgList provides a mock function for the type MockStore
func (_mock *MockStore) OrgList(listOptions *model.ListOptions) ([]*model.Org, error) {
	ret := _mock.Called(listOptions)

	if len(ret) == 0 {
		panic("no return value specified for OrgList")
	}

	var r0 []*model.Org
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) ([]*model.Org, error)); ok {
		return returnFunc(listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.ListOptions) []*model.Org); ok {
		r0 = returnFunc(listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Org)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.ListOptions) error); ok {
		r1 = returnFunc(listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgList'
type MockStore_OrgList_Call struct {
	*mock.Call
}

// OrgList is a helper method to define mock.On call
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) OrgList(listOptions interface{}) *MockStore_OrgList_Call {
	return &MockStore_OrgList_Call{Call: _e.mock.On("OrgList", listOptions)}
}

func (_c *MockStore_OrgList_Call) Run(run func(listOptions *model.ListOptions)) *MockStore_OrgList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.ListOptions
		if args[0] != nil {
			arg0 = args[0].(*model.ListOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_OrgList_Call) Return(orgs []*model.Org, err error) *MockStore_OrgList_Call {
	_c.Call.Return(orgs, err)
	return _c
}

func (_c *MockStore_OrgList_Call) RunAndReturn(run func(listOptions *model.ListOptions) ([]*model.Org, error)) *MockStore_OrgList_Call {
	_c.Call.Return(run)
	return _c
}

// OrgRegistryFind provides a mock function for the type MockStore
func (_mock *MockStore) OrgRegistryFind(n int64, s string) (*model.Registry, error) {
	ret := _mock.Called(n, s)

	if len(ret) == 0 {
		panic("no return value specified for OrgRegistryFind")
	}

	var r0 *model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, string) (*model.Registry, error)); ok {
		return returnFunc(n, s)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, string) *model.Registry); ok {
		r0 = returnFunc(n, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, string) error); ok {
		r1 = returnFunc(n, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgRegistryFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgRegistryFind'
type MockStore_OrgRegistryFind_Call struct {
	*mock.Call
}

// OrgRegistryFind is a helper method to define mock.On call
//   - n int64
//   - s string
func (_e *MockStore_Expecter) OrgRegistryFind(n interface{}, s interface{}) *MockStore_OrgRegistryFind_Call {
	return &MockStore_OrgRegistryFind_Call{Call: _e.mock.On("OrgRegistryFind", n, s)}
}

func (_c *MockStore_OrgRegistryFind_Call) Run(run func(n int64, s string)) *MockStore_OrgRegistryFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_OrgRegistryFind_Call) Return(registry *model.Registry, err error) *MockStore_OrgRegistryFind_Call {
	_c.Call.Return(registry, err)
	return _c
}

func (_c *MockStore_OrgRegistryFind_Call) RunAndReturn(run func(n int64, s string) (*model.Registry, error)) *MockStore_OrgRegistryFind_Call {
	_c.Call.Return(run)
	return _c
}

// OrgRegistryList provides a mock function for the type MockStore
func (_mock *MockStore) OrgRegistryList(n int64, listOptions *model.ListOptions) ([]*model.Registry, error) {
	ret := _mock.Called(n, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for OrgRegistryList")
	}

	var r0 []*model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, *model.ListOptions) ([]*model.Registry, error)); ok {
		return returnFunc(n, listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, *model.ListOptions) []*model.Registry); ok {
		r0 = returnFunc(n, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, *model.ListOptions) error); ok {
		r1 = returnFunc(n, listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgRegistryList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgRegistryList'
type MockStore_OrgRegistryList_Call struct {
	*mock.Call
}

// OrgRegistryList is a helper method to define mock.On call
//   - n int64
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) OrgRegistryList(n interface{}, listOptions interface{}) *MockStore_OrgRegistryList_Call {
	return &MockStore_OrgRegistryList_Call{Call: _e.mock.On("OrgRegistryList", n, listOptions)}
}

func (_c *MockStore_OrgRegistryList_Call) Run(run func(n int64, listOptions *model.ListOptions)) *MockStore_OrgRegistryList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_OrgRegistryList_Call) Return(registrys []*model.Registry, err error) *MockStore_OrgRegistryList_Call {
	_c.Call.Return(registrys, err)
	return _c
}

func (_c *MockStore_OrgRegistryList_Call) RunAndReturn(run func(n int64, listOptions *model.ListOptions) ([]*model.Registry, error)) *MockStore_OrgRegistryList_Call {
	_c.Call.Return(run)
	return _c
}

// OrgRepoList provides a mock function for the type MockStore
func (_mock *MockStore) OrgRepoList(org *model.Org, listOptions *model.ListOptions) ([]*model.Repo, error) {
	ret := _mock.Called(org, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for OrgRepoList")
	}

	var r0 []*model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Org, *model.ListOptions) ([]*model.Repo, error)); ok {
		return returnFunc(org, listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Org, *model.ListOptions) []*model.Repo); ok {
		r0 = returnFunc(org, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Org, *model.ListOptions) error); ok {
		r1 = returnFunc(org, listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgRepoList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgRepoList'
type MockStore_OrgRepoList_Call struct {
	*mock.Call
}

// OrgRepoList is a helper method to define mock.On call
//   - org *model.Org
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) OrgRepoList(org interface{}, listOptions interface{}) *MockStore_OrgRepoList_Call {
	return &MockStore_OrgRepoList_Call{Call: _e.mock.On("OrgRepoList", org, listOptions)}
}

func (_c *MockStore_OrgRepoList_Call) Run(run func(org *model.Org, listOptions *model.ListOptions)) *MockStore_OrgRepoList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Org
		if args[0] != nil {
			arg0 = args[0].(*model.Org)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_OrgRepoList_Call) Return(repos []*model.Repo, err error) *MockStore_OrgRepoList_Call {
	_c.Call.Return(repos, err)
	return _c
}

func (_c *MockStore_OrgRepoList_Call) RunAndReturn(run func(org *model.Org, listOptions *model.ListOptions) ([]*model.Repo, error)) *MockStore_OrgRepoList_Call {
	_c.Call.Return(run)
	return _c
}

// OrgSecretFind provides a mock function for the type MockStore
func (_mock *MockStore) OrgSecretFind(n int64, s string) (*model.Secret, error) {
	ret := _mock.Called(n, s)

	if len(ret) == 0 {
		panic("no return value specified for OrgSecretFind")
	}

	var r0 *model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, string) (*model.Secret, error)); ok {
		return returnFunc(n, s)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, string) *model.Secret); ok {
		r0 = returnFunc(n, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, string) error); ok {
		r1 = returnFunc(n, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgSecretFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgSecretFind'
type MockStore_OrgSecretFind_Call struct {
	*mock.Call
}

// OrgSecretFind is a helper method to define mock.On call
//   - n int64
//   - s string
func (_e *MockStore_Expecter) OrgSecretFind(n interface{}, s interface{}) *MockStore_OrgSecretFind_Call {
	return &MockStore_OrgSecretFind_Call{Call: _e.mock.On("OrgSecretFind", n, s)}
}

func (_c *MockStore_OrgSecretFind_Call) Run(run func(n int64, s string)) *MockStore_OrgSecretFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_OrgSecretFind_Call) Return(secret *model.Secret, err error) *MockStore_OrgSecretFind_Call {
	_c.Call.Return(secret, err)
	return _c
}

func (_c *MockStore_OrgSecretFind_Call) RunAndReturn(run func(n int64, s string) (*model.Secret, error)) *MockStore_OrgSecretFind_Call {
	_c.Call.Return(run)
	return _c
}

// OrgSecretList provides a mock function for the type MockStore
func (_mock *MockStore) OrgSecretList(n int64, listOptions *model.ListOptions) ([]*model.Secret, error) {
	ret := _mock.Called(n, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for OrgSecretList")
	}

	var r0 []*model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, *model.ListOptions) ([]*model.Secret, error)); ok {
		return returnFunc(n, listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, *model.ListOptions) []*model.Secret); ok {
		r0 = returnFunc(n, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, *model.ListOptions) error); ok {
		r1 = returnFunc(n, listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_OrgSecretList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgSecretList'
type MockStore_OrgSecretList_Call struct {
	*mock.Call
}

// OrgSecretList is a helper method to define mock.On call
//   - n int64
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) OrgSecretList(n interface{}, listOptions interface{}) *MockStore_OrgSecretList_Call {
	return &MockStore_OrgSecretList_Call{Call: _e.mock.On("OrgSecretList", n, listOptions)}
}

func (_c *MockStore_OrgSecretList_Call) Run(run func(n int64, listOptions *model.ListOptions)) *MockStore_OrgSecretList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_OrgSecretList_Call) Return(secrets []*model.Secret, err error) *MockStore_OrgSecretList_Call {
	_c.Call.Return(secrets, err)
	return _c
}

func (_c *MockStore_OrgSecretList_Call) RunAndReturn(run func(n int64, listOptions *model.ListOptions) ([]*model.Secret, error)) *MockStore_OrgSecretList_Call {
	_c.Call.Return(run)
	return _c
}

// OrgUpdate provides a mock function for the type MockStore
func (_mock *MockStore) OrgUpdate(org *model.Org) error {
	ret := _mock.Called(org)

	if len(ret) == 0 {
		panic("no return value specified for OrgUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Org) error); ok {
		r0 = returnFunc(org)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_OrgUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrgUpdate'
type MockStore_OrgUpdate_Call struct {
	*mock.Call
}

// OrgUpdate is a helper method to define mock.On call
//   - org *model.Org
func (_e *MockStore_Expecter) OrgUpdate(org interface{}) *MockStore_OrgUpdate_Call {
	return &MockStore_OrgUpdate_Call{Call: _e.mock.On("OrgUpdate", org)}
}

func (_c *MockStore_OrgUpdate_Call) Run(run func(org *model.Org)) *MockStore_OrgUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Org
		if args[0] != nil {
			arg0 = args[0].(*model.Org)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_OrgUpdate_Call) Return(err error) *MockStore_OrgUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_OrgUpdate_Call) RunAndReturn(run func(org *model.Org) error) *MockStore_OrgUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// PermFind provides a mock function for the type MockStore
func (_mock *MockStore) PermFind(user *model.User, repo *model.Repo) (*model.Perm, error) {
	ret := _mock.Called(user, repo)

	if len(ret) == 0 {
		panic("no return value specified for PermFind")
	}

	var r0 *model.Perm
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.User, *model.Repo) (*model.Perm, error)); ok {
		return returnFunc(user, repo)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.User, *model.Repo) *model.Perm); ok {
		r0 = returnFunc(user, repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Perm)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.User, *model.Repo) error); ok {
		r1 = returnFunc(user, repo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_PermFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PermFind'
type MockStore_PermFind_Call struct {
	*mock.Call
}

// PermFind is a helper method to define mock.On call
//   - user *model.User
//   - repo *model.Repo
func (_e *MockStore_Expecter) PermFind(user interface{}, repo interface{}) *MockStore_PermFind_Call {
	return &MockStore_PermFind_Call{Call: _e.mock.On("PermFind", user, repo)}
}

func (_c *MockStore_PermFind_Call) Run(run func(user *model.User, repo *model.Repo)) *MockStore_PermFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		var arg1 *model.Repo
		if args[1] != nil {
			arg1 = args[1].(*model.Repo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_PermFind_Call) Return(perm *model.Perm, err error) *MockStore_PermFind_Call {
	_c.Call.Return(perm, err)
	return _c
}

func (_c *MockStore_PermFind_Call) RunAndReturn(run func(user *model.User, repo *model.Repo) (*model.Perm, error)) *MockStore_PermFind_Call {
	_c.Call.Return(run)
	return _c
}

// PermUpsert provides a mock function for the type MockStore
func (_mock *MockStore) PermUpsert(perm *model.Perm) error {
	ret := _mock.Called(perm)

	if len(ret) == 0 {
		panic("no return value specified for PermUpsert")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Perm) error); ok {
		r0 = returnFunc(perm)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_PermUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PermUpsert'
type MockStore_PermUpsert_Call struct {
	*mock.Call
}

// PermUpsert is a helper method to define mock.On call
//   - perm *model.Perm
func (_e *MockStore_Expecter) PermUpsert(perm interface{}) *MockStore_PermUpsert_Call {
	return &MockStore_PermUpsert_Call{Call: _e.mock.On("PermUpsert", perm)}
}

func (_c *MockStore_PermUpsert_Call) Run(run func(perm *model.Perm)) *MockStore_PermUpsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Perm
		if args[0] != nil {
			arg0 = args[0].(*model.Perm)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_PermUpsert_Call) Return(err error) *MockStore_PermUpsert_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_PermUpsert_Call) RunAndReturn(run func(perm *model.Perm) error) *MockStore_PermUpsert_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function for the type MockStore
func (_mock *MockStore) Ping() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockStore_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
func (_e *MockStore_Expecter) Ping() *MockStore_Ping_Call {
	return &MockStore_Ping_Call{Call: _e.mock.On("Ping")}
}

func (_c *MockStore_Ping_Call) Run(run func()) *MockStore_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Ping_Call) Return(err error) *MockStore_Ping_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_Ping_Call) RunAndReturn(run func() error) *MockStore_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// PipelineConfigCreate provides a mock function for the type MockStore
func (_mock *MockStore) PipelineConfigCreate(pipelineConfig *model.PipelineConfig) error {
	ret := _mock.Called(pipelineConfig)

	if len(ret) == 0 {
		panic("no return value specified for PipelineConfigCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.PipelineConfig) error); ok {
		r0 = returnFunc(pipelineConfig)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_PipelineConfigCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PipelineConfigCreate'
type MockStore_PipelineConfigCreate_Call struct {
	*mock.Call
}

// PipelineConfigCreate is a helper method to define mock.On call
//   - pipelineConfig *model.PipelineConfig
func (_e *MockStore_Expecter) PipelineConfigCreate(pipelineConfig interface{}) *MockStore_PipelineConfigCreate_Call {
	return &MockStore_PipelineConfigCreate_Call{Call: _e.mock.On("PipelineConfigCreate", pipelineConfig)}
}

func (_c *MockStore_PipelineConfigCreate_Call) Run(run func(pipelineConfig *model.PipelineConfig)) *MockStore_PipelineConfigCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.PipelineConfig
		if args[0] != nil {
			arg0 = args[0].(*model.PipelineConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_PipelineConfigCreate_Call) Return(err error) *MockStore_PipelineConfigCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_PipelineConfigCreate_Call) RunAndReturn(run func(pipelineConfig *model.PipelineConfig) error) *MockStore_PipelineConfigCreate_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryCreate provides a mock function for the type MockStore
func (_mock *MockStore) RegistryCreate(registry *model.Registry) error {
	ret := _mock.Called(registry)

	if len(ret) == 0 {
		panic("no return value specified for RegistryCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Registry) error); ok {
		r0 = returnFunc(registry)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RegistryCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryCreate'
type MockStore_RegistryCreate_Call struct {
	*mock.Call
}

// RegistryCreate is a helper method to define mock.On call
//   - registry *model.Registry
func (_e *MockStore_Expecter) RegistryCreate(registry interface{}) *MockStore_RegistryCreate_Call {
	return &MockStore_RegistryCreate_Call{Call: _e.mock.On("RegistryCreate", registry)}
}

func (_c *MockStore_RegistryCreate_Call) Run(run func(registry *model.Registry)) *MockStore_RegistryCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Registry
		if args[0] != nil {
			arg0 = args[0].(*model.Registry)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_RegistryCreate_Call) Return(err error) *MockStore_RegistryCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RegistryCreate_Call) RunAndReturn(run func(registry *model.Registry) error) *MockStore_RegistryCreate_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryDelete provides a mock function for the type MockStore
func (_mock *MockStore) RegistryDelete(registry *model.Registry) error {
	ret := _mock.Called(registry)

	if len(ret) == 0 {
		panic("no return value specified for RegistryDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Registry) error); ok {
		r0 = returnFunc(registry)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RegistryDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryDelete'
type MockStore_RegistryDelete_Call struct {
	*mock.Call
}

// RegistryDelete is a helper method to define mock.On call
//   - registry *model.Registry
func (_e *MockStore_Expecter) RegistryDelete(registry interface{}) *MockStore_RegistryDelete_Call {
	return &MockStore_RegistryDelete_Call{Call: _e.mock.On("RegistryDelete", registry)}
}

func (_c *MockStore_RegistryDelete_Call) Run(run func(registry *model.Registry)) *MockStore_RegistryDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Registry
		if args[0] != nil {
			arg0 = args[0].(*model.Registry)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_RegistryDelete_Call) Return(err error) *MockStore_RegistryDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RegistryDelete_Call) RunAndReturn(run func(registry *model.Registry) error) *MockStore_RegistryDelete_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryFind provides a mock function for the type MockStore
func (_mock *MockStore) RegistryFind(repo *model.Repo, s string) (*model.Registry, error) {
	ret := _mock.Called(repo, s)

	if len(ret) == 0 {
		panic("no return value specified for RegistryFind")
	}

	var r0 *model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) (*model.Registry, error)); ok {
		return returnFunc(repo, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) *model.Registry); ok {
		r0 = returnFunc(repo, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, string) error); ok {
		r1 = returnFunc(repo, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_RegistryFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryFind'
type MockStore_RegistryFind_Call struct {
	*mock.Call
}

// RegistryFind is a helper method to define mock.On call
//   - repo *model.Repo
//   - s string
func (_e *MockStore_Expecter) RegistryFind(repo interface{}, s interface{}) *MockStore_RegistryFind_Call {
	return &MockStore_RegistryFind_Call{Call: _e.mock.On("RegistryFind", repo, s)}
}

func (_c *MockStore_RegistryFind_Call) Run(run func(repo *model.Repo, s string)) *MockStore_RegistryFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_RegistryFind_Call) Return(registry *model.Registry, err error) *MockStore_RegistryFind_Call {
	_c.Call.Return(registry, err)
	return _c
}

func (_c *MockStore_RegistryFind_Call) RunAndReturn(run func(repo *model.Repo, s string) (*model.Registry, error)) *MockStore_RegistryFind_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryList provides a mock function for the type MockStore
func (_mock *MockStore) RegistryList(repo *model.Repo, b bool, listOptions *model.ListOptions) ([]*model.Registry, error) {
	ret := _mock.Called(repo, b, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for RegistryList")
	}

	var r0 []*model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, bool, *model.ListOptions) ([]*model.Registry, error)); ok {
		return returnFunc(repo, b, listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, bool, *model.ListOptions) []*model.Registry); ok {
		r0 = returnFunc(repo, b, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, bool, *model.ListOptions) error); ok {
		r1 = returnFunc(repo, b, listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_RegistryList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryList'
type MockStore_RegistryList_Call struct {
	*mock.Call
}

// RegistryList is a helper method to define mock.On call
//   - repo *model.Repo
//   - b bool
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) RegistryList(repo interface{}, b interface{}, listOptions interface{}) *MockStore_RegistryList_Call {
	return &MockStore_RegistryList_Call{Call: _e.mock.On("RegistryList", repo, b, listOptions)}
}

func (_c *MockStore_RegistryList_Call) Run(run func(repo *model.Repo, b bool, listOptions *model.ListOptions)) *MockStore_RegistryList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 *model.ListOptions
		if args[2] != nil {
			arg2 = args[2].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_RegistryList_Call) Return(registrys []*model.Registry, err error) *MockStore_RegistryList_Call {
	_c.Call.Return(registrys, err)
	return _c
}

func (_c *MockStore_RegistryList_Call) RunAndReturn(run func(repo *model.Repo, b bool, listOptions *model.ListOptions) ([]*model.Registry, error)) *MockStore_RegistryList_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryListAll provides a mock function for the type MockStore
func (_mock *MockStore) RegistryListAll() ([]*model.Registry, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RegistryListAll")
	}

	var r0 []*model.Registry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]*model.Registry, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []*model.Registry); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Registry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_RegistryListAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryListAll'
type MockStore_RegistryListAll_Call struct {
	*mock.Call
}

// RegistryListAll is a helper method to define mock.On call
func (_e *MockStore_Expecter) RegistryListAll() *MockStore_RegistryListAll_Call {
	return &MockStore_RegistryListAll_Call{Call: _e.mock.On("RegistryListAll")}
}

func (_c *MockStore_RegistryListAll_Call) Run(run func()) *MockStore_RegistryListAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_RegistryListAll_Call) Return(registrys []*model.Registry, err error) *MockStore_RegistryListAll_Call {
	_c.Call.Return(registrys, err)
	return _c
}

func (_c *MockStore_RegistryListAll_Call) RunAndReturn(run func() ([]*model.Registry, error)) *MockStore_RegistryListAll_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryUpdate provides a mock function for the type MockStore
func (_mock *MockStore) RegistryUpdate(registry *model.Registry) error {
	ret := _mock.Called(registry)

	if len(ret) == 0 {
		panic("no return value specified for RegistryUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Registry) error); ok {
		r0 = returnFunc(registry)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RegistryUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryUpdate'
type MockStore_RegistryUpdate_Call struct {
	*mock.Call
}

// RegistryUpdate is a helper method to define mock.On call
//   - registry *model.Registry
func (_e *MockStore_Expecter) RegistryUpdate(registry interface{}) *MockStore_RegistryUpdate_Call {
	return &MockStore_RegistryUpdate_Call{Call: _e.mock.On("RegistryUpdate", registry)}
}

func (_c *MockStore_RegistryUpdate_Call) Run(run func(registry *model.Registry)) *MockStore_RegistryUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Registry
		if args[0] != nil {
			arg0 = args[0].(*model.Registry)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_RegistryUpdate_Call) Return(err error) *MockStore_RegistryUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RegistryUpdate_Call) RunAndReturn(run func(registry *model.Registry) error) *MockStore_RegistryUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// RepoList provides a mock function for the type MockStore
func (_mock *MockStore) RepoList(user *model.User, owned bool, active bool, filter *model.RepoFilter) ([]*model.Repo, error) {
	ret := _mock.Called(user, owned, active, filter)

	if len(ret) == 0 {
		panic("no return value specified for RepoList")
	}

	var r0 []*model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.User, bool, bool, *model.RepoFilter) ([]*model.Repo, error)); ok {
		return returnFunc(user, owned, active, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.User, bool, bool, *model.RepoFilter) []*model.Repo); ok {
		r0 = returnFunc(user, owned, active, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.User, bool, bool, *model.RepoFilter) error); ok {
		r1 = returnFunc(user, owned, active, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_RepoList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepoList'
type MockStore_RepoList_Call struct {
	*mock.Call
}

// RepoList is a helper method to define mock.On call
//   - user *model.User
//   - owned bool
//   - active bool
//   - filter *model.RepoFilter
func (_e *MockStore_Expecter) RepoList(user interface{}, owned interface{}, active interface{}, filter interface{}) *MockStore_RepoList_Call {
	return &MockStore_RepoList_Call{Call: _e.mock.On("RepoList", user, owned, active, filter)}
}

func (_c *MockStore_RepoList_Call) Run(run func(user *model.User, owned bool, active bool, filter *model.RepoFilter)) *MockStore_RepoList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		var arg3 *model.RepoFilter
		if args[3] != nil {
			arg3 = args[3].(*model.RepoFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_RepoList_Call) Return(repos []*model.Repo, err error) *MockStore_RepoList_Call {
	_c.Call.Return(repos, err)
	return _c
}

func (_c *MockStore_RepoList_Call) RunAndReturn(run func(user *model.User, owned bool, active bool, filter *model.RepoFilter) ([]*model.Repo, error)) *MockStore_RepoList_Call {
	_c.Call.Return(run)
	return _c
}

// RepoListAll provides a mock function for the type MockStore
func (_mock *MockStore) RepoListAll(active bool, p *model.ListOptions) ([]*model.Repo, error) {
	ret := _mock.Called(active, p)

	if len(ret) == 0 {
		panic("no return value specified for RepoListAll")
	}

	var r0 []*model.Repo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(bool, *model.ListOptions) ([]*model.Repo, error)); ok {
		return returnFunc(active, p)
	}
	if returnFunc, ok := ret.Get(0).(func(bool, *model.ListOptions) []*model.Repo); ok {
		r0 = returnFunc(active, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Repo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(bool, *model.ListOptions) error); ok {
		r1 = returnFunc(active, p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_RepoListAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepoListAll'
type MockStore_RepoListAll_Call struct {
	*mock.Call
}

// RepoListAll is a helper method to define mock.On call
//   - active bool
//   - p *model.ListOptions
func (_e *MockStore_Expecter) RepoListAll(active interface{}, p interface{}) *MockStore_RepoListAll_Call {
	return &MockStore_RepoListAll_Call{Call: _e.mock.On("RepoListAll", active, p)}
}

func (_c *MockStore_RepoListAll_Call) Run(run func(active bool, p *model.ListOptions)) *MockStore_RepoListAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 bool
		if args[0] != nil {
			arg0 = args[0].(bool)
		}
		var arg1 *model.ListOptions
		if args[1] != nil {
			arg1 = args[1].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_RepoListAll_Call) Return(repos []*model.Repo, err error) *MockStore_RepoListAll_Call {
	_c.Call.Return(repos, err)
	return _c
}

func (_c *MockStore_RepoListAll_Call) RunAndReturn(run func(active bool, p *model.ListOptions) ([]*model.Repo, error)) *MockStore_RepoListAll_Call {
	_c.Call.Return(run)
	return _c
}

// RepoListLatest provides a mock function for the type MockStore
func (_mock *MockStore) RepoListLatest(user *model.User) ([]*model.Feed, error) {
	ret := _mock.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for RepoListLatest")
	}

	var r0 []*model.Feed
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.User) ([]*model.Feed, error)); ok {
		return returnFunc(user)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.User) []*model.Feed); ok {
		r0 = returnFunc(user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Feed)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.User) error); ok {
		r1 = returnFunc(user)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_RepoListLatest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepoListLatest'
type MockStore_RepoListLatest_Call struct {
	*mock.Call
}

// RepoListLatest is a helper method to define mock.On call
//   - user *model.User
func (_e *MockStore_Expecter) RepoListLatest(user interface{}) *MockStore_RepoListLatest_Call {
	return &MockStore_RepoListLatest_Call{Call: _e.mock.On("RepoListLatest", user)}
}

func (_c *MockStore_RepoListLatest_Call) Run(run func(user *model.User)) *MockStore_RepoListLatest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_RepoListLatest_Call) Return(feeds []*model.Feed, err error) *MockStore_RepoListLatest_Call {
	_c.Call.Return(feeds, err)
	return _c
}

func (_c *MockStore_RepoListLatest_Call) RunAndReturn(run func(user *model.User) ([]*model.Feed, error)) *MockStore_RepoListLatest_Call {
	_c.Call.Return(run)
	return _c
}

// SecretCreate provides a mock function for the type MockStore
func (_mock *MockStore) SecretCreate(secret *model.Secret) error {
	ret := _mock.Called(secret)

	if len(ret) == 0 {
		panic("no return value specified for SecretCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Secret) error); ok {
		r0 = returnFunc(secret)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SecretCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecretCreate'
type MockStore_SecretCreate_Call struct {
	*mock.Call
}

// SecretCreate is a helper method to define mock.On call
//   - secret *model.Secret
func (_e *MockStore_Expecter) SecretCreate(secret interface{}) *MockStore_SecretCreate_Call {
	return &MockStore_SecretCreate_Call{Call: _e.mock.On("SecretCreate", secret)}
}

func (_c *MockStore_SecretCreate_Call) Run(run func(secret *model.Secret)) *MockStore_SecretCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Secret
		if args[0] != nil {
			arg0 = args[0].(*model.Secret)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_SecretCreate_Call) Return(err error) *MockStore_SecretCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SecretCreate_Call) RunAndReturn(run func(secret *model.Secret) error) *MockStore_SecretCreate_Call {
	_c.Call.Return(run)
	return _c
}

// SecretDelete provides a mock function for the type MockStore
func (_mock *MockStore) SecretDelete(secret *model.Secret) error {
	ret := _mock.Called(secret)

	if len(ret) == 0 {
		panic("no return value specified for SecretDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Secret) error); ok {
		r0 = returnFunc(secret)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SecretDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecretDelete'
type MockStore_SecretDelete_Call struct {
	*mock.Call
}

// SecretDelete is a helper method to define mock.On call
//   - secret *model.Secret
func (_e *MockStore_Expecter) SecretDelete(secret interface{}) *MockStore_SecretDelete_Call {
	return &MockStore_SecretDelete_Call{Call: _e.mock.On("SecretDelete", secret)}
}

func (_c *MockStore_SecretDelete_Call) Run(run func(secret *model.Secret)) *MockStore_SecretDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Secret
		if args[0] != nil {
			arg0 = args[0].(*model.Secret)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_SecretDelete_Call) Return(err error) *MockStore_SecretDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SecretDelete_Call) RunAndReturn(run func(secret *model.Secret) error) *MockStore_SecretDelete_Call {
	_c.Call.Return(run)
	return _c
}

// SecretFind provides a mock function for the type MockStore
func (_mock *MockStore) SecretFind(repo *model.Repo, s string) (*model.Secret, error) {
	ret := _mock.Called(repo, s)

	if len(ret) == 0 {
		panic("no return value specified for SecretFind")
	}

	var r0 *model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) (*model.Secret, error)); ok {
		return returnFunc(repo, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, string) *model.Secret); ok {
		r0 = returnFunc(repo, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, string) error); ok {
		r1 = returnFunc(repo, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_SecretFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecretFind'
type MockStore_SecretFind_Call struct {
	*mock.Call
}

// SecretFind is a helper method to define mock.On call
//   - repo *model.Repo
//   - s string
func (_e *MockStore_Expecter) SecretFind(repo interface{}, s interface{}) *MockStore_SecretFind_Call {
	return &MockStore_SecretFind_Call{Call: _e.mock.On("SecretFind", repo, s)}
}

func (_c *MockStore_SecretFind_Call) Run(run func(repo *model.Repo, s string)) *MockStore_SecretFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_SecretFind_Call) Return(secret *model.Secret, err error) *MockStore_SecretFind_Call {
	_c.Call.Return(secret, err)
	return _c
}

func (_c *MockStore_SecretFind_Call) RunAndReturn(run func(repo *model.Repo, s string) (*model.Secret, error)) *MockStore_SecretFind_Call {
	_c.Call.Return(run)
	return _c
}

// SecretList provides a mock function for the type MockStore
func (_mock *MockStore) SecretList(repo *model.Repo, b bool, listOptions *model.ListOptions) ([]*model.Secret, error) {
	ret := _mock.Called(repo, b, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for SecretList")
	}

	var r0 []*model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, bool, *model.ListOptions) ([]*model.Secret, error)); ok {
		return returnFunc(repo, b, listOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Repo, bool, *model.ListOptions) []*model.Secret); ok {
		r0 = returnFunc(repo, b, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Repo, bool, *model.ListOptions) error); ok {
		r1 = returnFunc(repo, b, listOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_SecretList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecretList'
type MockStore_SecretList_Call struct {
	*mock.Call
}

// SecretList is a helper method to define mock.On call
//   - repo *model.Repo
//   - b bool
//   - listOptions *model.ListOptions
func (_e *MockStore_Expecter) SecretList(repo interface{}, b interface{}, listOptions interface{}) *MockStore_SecretList_Call {
	return &MockStore_SecretList_Call{Call: _e.mock.On("SecretList", repo, b, listOptions)}
}

func (_c *MockStore_SecretList_Call) Run(run func(repo *model.Repo, b bool, listOptions *model.ListOptions)) *MockStore_SecretList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 *model.ListOptions
		if args[2] != nil {
			arg2 = args[2].(*model.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_SecretList_Call) Return(secrets []*model.Secret, err error) *MockStore_SecretList_Call {
	_c.Call.Return(secrets, err)
	return _c
}

func (_c *MockStore_SecretList_Call) RunAndReturn(run func(repo *model.Repo, b bool, listOptions *model.ListOptions) ([]*model.Secret, error)) *MockStore_SecretList_Call {
	_c.Call.Return(run)
	return _c
}

// SecretListAll provides a mock function for the type MockStore
func (_mock *MockStore) SecretListAll() ([]*model.Secret, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SecretListAll")
	}

	var r0 []*model.Secret
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]*model.Secret, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []*model.Secret); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Secret)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_SecretListAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecretListAll'
type MockStore_SecretListAll_Call struct {
	*mock.Call
}

// SecretListAll is a helper method to define mock.On call
func (_e *MockStore_Expecter) SecretListAll() *MockStore_SecretListAll_Call {
	return &MockStore_SecretListAll_Call{Call: _e.mock.On("SecretListAll")}
}

func (_c *MockStore_SecretListAll_Call) Run(run func()) *MockStore_SecretListAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_SecretListAll_Call) Return(secrets []*model.Secret, err error) *MockStore_SecretListAll_Call {
	_c.Call.Return(secrets, err)
	return _c
}

func (_c *MockStore_SecretListAll_Call) RunAndReturn(run func() ([]*model.Secret, error)) *MockStore_SecretListAll_Call {
	_c.Call.Return(run)
	return _c
}

// SecretUpdate provides a mock function for the type MockStore
func (_mock *MockStore) SecretUpdate(secret *model.Secret) error {
	ret := _mock.Called(secret)

	if len(ret) == 0 {
		panic("no return value specified for SecretUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Secret) error); ok {
		r0 = returnFunc(secret)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SecretUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecretUpdate'
type MockStore_SecretUpdate_Call struct {
	*mock.Call
}

// SecretUpdate is a helper method to define mock.On call
//   - secret *model.Secret
func (_e *MockStore_Expecter) SecretUpdate(secret interface{}) *MockStore_SecretUpdate_Call {
	return &MockStore_SecretUpdate_Call{Call: _e.mock.On("SecretUpdate", secret)}
}

func (_c *MockStore_SecretUpdate_Call) Run(run func(secret *model.Secret)) *MockStore_SecretUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Secret
		if args[0] != nil {
			arg0 = args[0].(*model.Secret)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_SecretUpdate_Call) Return(err error) *MockStore_SecretUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SecretUpdate_Call) RunAndReturn(run func(secret *model.Secret) error) *MockStore_SecretUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// ServerConfigDelete provides a mock function for the type MockStore
func (_mock *MockStore) ServerConfigDelete(s string) error {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for ServerConfigDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ServerConfigDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerConfigDelete'
type MockStore_ServerConfigDelete_Call struct {
	*mock.Call
}

// ServerConfigDelete is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) ServerConfigDelete(s interface{}) *MockStore_ServerConfigDelete_Call {
	return &MockStore_ServerConfigDelete_Call{Call: _e.mock.On("ServerConfigDelete", s)}
}

func (_c *MockStore_ServerConfigDelete_Call) Run(run func(s string)) *MockStore_ServerConfigDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ServerConfigDelete_Call) Return(err error) *MockStore_ServerConfigDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ServerConfigDelete_Call) RunAndReturn(run func(s string) error) *MockStore_ServerConfigDelete_Call {
	_c.Call.Return(run)
	return _c
}

// ServerConfigGet provides a mock function for the type MockStore
func (_mock *MockStore) ServerConfigGet(s string) (string, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for ServerConfigGet")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ServerConfigGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerConfigGet'
type MockStore_ServerConfigGet_Call struct {
	*mock.Call
}

// ServerConfigGet is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) ServerConfigGet(s interface{}) *MockStore_ServerConfigGet_Call {
	return &MockStore_ServerConfigGet_Call{Call: _e.mock.On("ServerConfigGet", s)}
}

func (_c *MockStore_ServerConfigGet_Call) Run(run func(s string)) *MockStore_ServerConfigGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ServerConfigGet_Call) Return(s1 string, err error) *MockStore_ServerConfigGet_Call {
	_c.Call.Return(s1, err)
	return _c
}

func (_c *MockStore_ServerConfigGet_Call) RunAndReturn(run func(s string) (string, error)) *MockStore_ServerConfigGet_Call {
	_c.Call.Return(run)
	return _c
}

// ServerConfigSet provides a mock function for the type MockStore
func (_mock *MockStore) ServerConfigSet(s string, s1 string) error {
	ret := _mock.Called(s, s1)

	if len(ret) == 0 {
		panic("no return value specified for ServerConfigSet")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(s, s1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ServerConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerConfigSet'
type MockStore_ServerConfigSet_Call struct {
	*mock.Call
}

// ServerConfigSet is a helper method to define mock.On call
//   - s string
//   - s1 string
func (_e *MockStore_Expecter) ServerConfigSet(s interface{}, s1 interface{}) *MockStore_ServerConfigSet_Call {
	return &MockStore_ServerConfigSet_Call{Call: _e.mock.On("ServerConfigSet", s, s1)}
}

func (_c *MockStore_ServerConfigSet_Call) Run(run func(s string, s1 string)) *MockStore_ServerConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ServerConfigSet_Call) Return(err error) *MockStore_ServerConfigSet_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ServerConfigSet_Call) RunAndReturn(run func(s string, s1 string) error) *MockStore_ServerConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// StepByUUID provides a mock function for the type MockStore
func (_mock *MockStore) StepByUUID(s string) (*model.Step, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for StepByUUID")
	}

	var r0 *model.Step
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*model.Step, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *model.Step); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Step)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_StepByUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepByUUID'
type MockStore_StepByUUID_Call struct {
	*mock.Call
}

// StepByUUID is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) StepByUUID(s interface{}) *MockStore_StepByUUID_Call {
	return &MockStore_StepByUUID_Call{Call: _e.mock.On("StepByUUID", s)}
}

func (_c *MockStore_StepByUUID_Call) Run(run func(s string)) *MockStore_StepByUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_StepByUUID_Call) Return(step *model.Step, err error) *MockStore_StepByUUID_Call {
	_c.Call.Return(step, err)
	return _c
}

func (_c *MockStore_StepByUUID_Call) RunAndReturn(run func(s string) (*model.Step, error)) *MockStore_StepByUUID_Call {
	_c.Call.Return(run)
	return _c
}

// StepChild provides a mock function for the type MockStore
func (_mock *MockStore) StepChild(pipeline *model.Pipeline, n int, s string) (*model.Step, error) {
	ret := _mock.Called(pipeline, n, s)

	if len(ret) == 0 {
		panic("no return value specified for StepChild")
	}

	var r0 *model.Step
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline, int, string) (*model.Step, error)); ok {
		return returnFunc(pipeline, n, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline, int, string) *model.Step); ok {
		r0 = returnFunc(pipeline, n, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Step)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Pipeline, int, string) error); ok {
		r1 = returnFunc(pipeline, n, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_StepChild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepChild'
type MockStore_StepChild_Call struct {
	*mock.Call
}

// StepChild is a helper method to define mock.On call
//   - pipeline *model.Pipeline
//   - n int
//   - s string
func (_e *MockStore_Expecter) StepChild(pipeline interface{}, n interface{}, s interface{}) *MockStore_StepChild_Call {
	return &MockStore_StepChild_Call{Call: _e.mock.On("StepChild", pipeline, n, s)}
}

func (_c *MockStore_StepChild_Call) Run(run func(pipeline *model.Pipeline, n int, s string)) *MockStore_StepChild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_StepChild_Call) Return(step *model.Step, err error) *MockStore_StepChild_Call {
	_c.Call.Return(step, err)
	return _c
}

func (_c *MockStore_StepChild_Call) RunAndReturn(run func(pipeline *model.Pipeline, n int, s string) (*model.Step, error)) *MockStore_StepChild_Call {
	_c.Call.Return(run)
	return _c
}

// StepFind provides a mock function for the type MockStore
func (_mock *MockStore) StepFind(pipeline *model.Pipeline, n int) (*model.Step, error) {
	ret := _mock.Called(pipeline, n)

	if len(ret) == 0 {
		panic("no return value specified for StepFind")
	}

	var r0 *model.Step
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline, int) (*model.Step, error)); ok {
		return returnFunc(pipeline, n)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline, int) *model.Step); ok {
		r0 = returnFunc(pipeline, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Step)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Pipeline, int) error); ok {
		r1 = returnFunc(pipeline, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_StepFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepFind'
type MockStore_StepFind_Call struct {
	*mock.Call
}

// StepFind is a helper method to define mock.On call
//   - pipeline *model.Pipeline
//   - n int
func (_e *MockStore_Expecter) StepFind(pipeline interface{}, n interface{}) *MockStore_StepFind_Call {
	return &MockStore_StepFind_Call{Call: _e.mock.On("StepFind", pipeline, n)}
}

func (_c *MockStore_StepFind_Call) Run(run func(pipeline *model.Pipeline, n int)) *MockStore_StepFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_StepFind_Call) Return(step *model.Step, err error) *MockStore_StepFind_Call {
	_c.Call.Return(step, err)
	return _c
}

func (_c *MockStore_StepFind_Call) RunAndReturn(run func(pipeline *model.Pipeline, n int) (*model.Step, error)) *MockStore_StepFind_Call {
	_c.Call.Return(run)
	return _c
}

// StepFinished provides a mock function for the type MockStore
func (_mock *MockStore) StepFinished(step *model.Step) {
	_mock.Called(step)
	return
}

// MockStore_StepFinished_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepFinished'
type MockStore_StepFinished_Call struct {
	*mock.Call
}

// StepFinished is a helper method to define mock.On call
//   - step *model.Step
func (_e *MockStore_Expecter) StepFinished(step interface{}) *MockStore_StepFinished_Call {
	return &MockStore_StepFinished_Call{Call: _e.mock.On("StepFinished", step)}
}

func (_c *MockStore_StepFinished_Call) Run(run func(step *model.Step)) *MockStore_StepFinished_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Step
		if args[0] != nil {
			arg0 = args[0].(*model.Step)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_StepFinished_Call) Return() *MockStore_StepFinished_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStore_StepFinished_Call) RunAndReturn(run func(step *model.Step)) *MockStore_StepFinished_Call {
	_c.Run(run)
	return _c
}

// StepList provides a mock function for the type MockStore
func (_mock *MockStore) StepList(pipeline *model.Pipeline) ([]*model.Step, error) {
	ret := _mock.Called(pipeline)

	if len(ret) == 0 {
		panic("no return value specified for StepList")
	}

	var r0 []*model.Step
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline) ([]*model.Step, error)); ok {
		return returnFunc(pipeline)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline) []*model.Step); ok {
		r0 = returnFunc(pipeline)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Step)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Pipeline) error); ok {
		r1 = returnFunc(pipeline)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_StepList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepList'
type MockStore_StepList_Call struct {
	*mock.Call
}

// StepList is a helper method to define mock.On call
//   - pipeline *model.Pipeline
func (_e *MockStore_Expecter) StepList(pipeline interface{}) *MockStore_StepList_Call {
	return &MockStore_StepList_Call{Call: _e.mock.On("StepList", pipeline)}
}

func (_c *MockStore_StepList_Call) Run(run func(pipeline *model.Pipeline)) *MockStore_StepList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_StepList_Call) Return(steps []*model.Step, err error) *MockStore_StepList_Call {
	_c.Call.Return(steps, err)
	return _c
}

func (_c *MockStore_StepList_Call) RunAndReturn(run func(pipeline *model.Pipeline) ([]*model.Step, error)) *MockStore_StepList_Call {
	_c.Call.Return(run)
	return _c
}

// StepListFromWorkflowFind provides a mock function for the type MockStore
func (_mock *MockStore) StepListFromWorkflowFind(workflow *model.Workflow) ([]*model.Step, error) {
	ret := _mock.Called(workflow)

	if len(ret) == 0 {
		panic("no return value specified for StepListFromWorkflowFind")
	}

	var r0 []*model.Step
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Workflow) ([]*model.Step, error)); ok {
		return returnFunc(workflow)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Workflow) []*model.Step); ok {
		r0 = returnFunc(workflow)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Step)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Workflow) error); ok {
		r1 = returnFunc(workflow)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_StepListFromWorkflowFind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepListFromWorkflowFind'
type MockStore_StepListFromWorkflowFind_Call struct {
	*mock.Call
}

// StepListFromWorkflowFind is a helper method to define mock.On call
//   - workflow *model.Workflow
func (_e *MockStore_Expecter) StepListFromWorkflowFind(workflow interface{}) *MockStore_StepListFromWorkflowFind_Call {
	return &MockStore_StepListFromWorkflowFind_Call{Call: _e.mock.On("StepListFromWorkflowFind", workflow)}
}

func (_c *MockStore_StepListFromWorkflowFind_Call) Run(run func(workflow *model.Workflow)) *MockStore_StepListFromWorkflowFind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Workflow
		if args[0] != nil {
			arg0 = args[0].(*model.Workflow)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_StepListFromWorkflowFind_Call) Return(steps []*model.Step, err error) *MockStore_StepListFromWorkflowFind_Call {
	_c.Call.Return(steps, err)
	return _c
}

func (_c *MockStore_StepListFromWorkflowFind_Call) RunAndReturn(run func(workflow *model.Workflow) ([]*model.Step, error)) *MockStore_StepListFromWorkflowFind_Call {
	_c.Call.Return(run)
	return _c
}

// StepLoad provides a mock function for the type MockStore
func (_mock *MockStore) StepLoad(n int64) (*model.Step, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for StepLoad")
	}

	var r0 *model.Step
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Step, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Step); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Step)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_StepLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepLoad'
type MockStore_StepLoad_Call struct {
	*mock.Call
}

// StepLoad is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) StepLoad(n interface{}) *MockStore_StepLoad_Call {
	return &MockStore_StepLoad_Call{Call: _e.mock.On("StepLoad", n)}
}

func (_c *MockStore_StepLoad_Call) Run(run func(n int64)) *MockStore_StepLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_StepLoad_Call) Return(step *model.Step, err error) *MockStore_StepLoad_Call {
	_c.Call.Return(step, err)
	return _c
}

func (_c *MockStore_StepLoad_Call) RunAndReturn(run func(n int64) (*model.Step, error)) *MockStore_StepLoad_Call {
	_c.Call.Return(run)
	return _c
}

// StepUpdate provides a mock function for the type MockStore
func (_mock *MockStore) StepUpdate(step *model.Step) error {
	ret := _mock.Called(step)

	if len(ret) == 0 {
		panic("no return value specified for StepUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Step) error); ok {
		r0 = returnFunc(step)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_StepUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepUpdate'
type MockStore_StepUpdate_Call struct {
	*mock.Call
}

// StepUpdate is a helper method to define mock.On call
//   - step *model.Step
func (_e *MockStore_Expecter) StepUpdate(step interface{}) *MockStore_StepUpdate_Call {
	return &MockStore_StepUpdate_Call{Call: _e.mock.On("StepUpdate", step)}
}

func (_c *MockStore_StepUpdate_Call) Run(run func(step *model.Step)) *MockStore_StepUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Step
		if args[0] != nil {
			arg0 = args[0].(*model.Step)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_StepUpdate_Call) Return(err error) *MockStore_StepUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_StepUpdate_Call) RunAndReturn(run func(step *model.Step) error) *MockStore_StepUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// TaskDelete provides a mock function for the type MockStore
func (_mock *MockStore) TaskDelete(s string) error {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for TaskDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TaskDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TaskDelete'
type MockStore_TaskDelete_Call struct {
	*mock.Call
}

// TaskDelete is a helper method to define mock.On call
//   - s string
func (_e *MockStore_Expecter) TaskDelete(s interface{}) *MockStore_TaskDelete_Call {
	return &MockStore_TaskDelete_Call{Call: _e.mock.On("TaskDelete", s)}
}

func (_c *MockStore_TaskDelete_Call) Run(run func(s string)) *MockStore_TaskDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_TaskDelete_Call) Return(err error) *MockStore_TaskDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TaskDelete_Call) RunAndReturn(run func(s string) error) *MockStore_TaskDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TaskInsert provides a mock function for the type MockStore
func (_mock *MockStore) TaskInsert(task *model.Task) error {
	ret := _mock.Called(task)

	if len(ret) == 0 {
		panic("no return value specified for TaskInsert")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Task) error); ok {
		r0 = returnFunc(task)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_TaskInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TaskInsert'
type MockStore_TaskInsert_Call struct {
	*mock.Call
}

// TaskInsert is a helper method to define mock.On call
//   - task *model.Task
func (_e *MockStore_Expecter) TaskInsert(task interface{}) *MockStore_TaskInsert_Call {
	return &MockStore_TaskInsert_Call{Call: _e.mock.On("TaskInsert", task)}
}

func (_c *MockStore_TaskInsert_Call) Run(run func(task *model.Task)) *MockStore_TaskInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Task
		if args[0] != nil {
			arg0 = args[0].(*model.Task)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_TaskInsert_Call) Return(err error) *MockStore_TaskInsert_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_TaskInsert_Call) RunAndReturn(run func(task *model.Task) error) *MockStore_TaskInsert_Call {
	_c.Call.Return(run)
	return _c
}

// TaskList provides a mock function for the type MockStore
func (_mock *MockStore) TaskList() ([]*model.Task, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TaskList")
	}

	var r0 []*model.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]*model.Task, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []*model.Task); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Task)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_TaskList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TaskList'
type MockStore_TaskList_Call struct {
	*mock.Call
}

// TaskList is a helper method to define mock.On call
func (_e *MockStore_Expecter) TaskList() *MockStore_TaskList_Call {
	return &MockStore_TaskList_Call{Call: _e.mock.On("TaskList")}
}

func (_c *MockStore_TaskList_Call) Run(run func()) *MockStore_TaskList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_TaskList_Call) Return(tasks []*model.Task, err error) *MockStore_TaskList_Call {
	_c.Call.Return(tasks, err)
	return _c
}

func (_c *MockStore_TaskList_Call) RunAndReturn(run func() ([]*model.Task, error)) *MockStore_TaskList_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePipeline provides a mock function for the type MockStore
func (_mock *MockStore) UpdatePipeline(pipeline *model.Pipeline) error {
	ret := _mock.Called(pipeline)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePipeline")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline) error); ok {
		r0 = returnFunc(pipeline)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdatePipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePipeline'
type MockStore_UpdatePipeline_Call struct {
	*mock.Call
}

// UpdatePipeline is a helper method to define mock.On call
//   - pipeline *model.Pipeline
func (_e *MockStore_Expecter) UpdatePipeline(pipeline interface{}) *MockStore_UpdatePipeline_Call {
	return &MockStore_UpdatePipeline_Call{Call: _e.mock.On("UpdatePipeline", pipeline)}
}

func (_c *MockStore_UpdatePipeline_Call) Run(run func(pipeline *model.Pipeline)) *MockStore_UpdatePipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_UpdatePipeline_Call) Return(err error) *MockStore_UpdatePipeline_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdatePipeline_Call) RunAndReturn(run func(pipeline *model.Pipeline) error) *MockStore_UpdatePipeline_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRepo provides a mock function for the type MockStore
func (_mock *MockStore) UpdateRepo(repo *model.Repo) error {
	ret := _mock.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Repo) error); ok {
		r0 = returnFunc(repo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRepo'
type MockStore_UpdateRepo_Call struct {
	*mock.Call
}

// UpdateRepo is a helper method to define mock.On call
//   - repo *model.Repo
func (_e *MockStore_Expecter) UpdateRepo(repo interface{}) *MockStore_UpdateRepo_Call {
	return &MockStore_UpdateRepo_Call{Call: _e.mock.On("UpdateRepo", repo)}
}

func (_c *MockStore_UpdateRepo_Call) Run(run func(repo *model.Repo)) *MockStore_UpdateRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Repo
		if args[0] != nil {
			arg0 = args[0].(*model.Repo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_UpdateRepo_Call) Return(err error) *MockStore_UpdateRepo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateRepo_Call) RunAndReturn(run func(repo *model.Repo) error) *MockStore_UpdateRepo_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function for the type MockStore
func (_mock *MockStore) UpdateUser(user *model.User) error {
	ret := _mock.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.User) error); ok {
		r0 = returnFunc(user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockStore_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - user *model.User
func (_e *MockStore_Expecter) UpdateUser(user interface{}) *MockStore_UpdateUser_Call {
	return &MockStore_UpdateUser_Call{Call: _e.mock.On("UpdateUser", user)}
}

func (_c *MockStore_UpdateUser_Call) Run(run func(user *model.User)) *MockStore_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_UpdateUser_Call) Return(err error) *MockStore_UpdateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateUser_Call) RunAndReturn(run func(user *model.User) error) *MockStore_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UserFeed provides a mock function for the type MockStore
func (_mock *MockStore) UserFeed(user *model.User) ([]*model.Feed, error) {
	ret := _mock.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for UserFeed")
	}

	var r0 []*model.Feed
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.User) ([]*model.Feed, error)); ok {
		return returnFunc(user)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.User) []*model.Feed); ok {
		r0 = returnFunc(user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Feed)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.User) error); ok {
		r1 = returnFunc(user)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_UserFeed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserFeed'
type MockStore_UserFeed_Call struct {
	*mock.Call
}

// UserFeed is a helper method to define mock.On call
//   - user *model.User
func (_e *MockStore_Expecter) UserFeed(user interface{}) *MockStore_UserFeed_Call {
	return &MockStore_UserFeed_Call{Call: _e.mock.On("UserFeed", user)}
}

func (_c *MockStore_UserFeed_Call) Run(run func(user *model.User)) *MockStore_UserFeed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.User
		if args[0] != nil {
			arg0 = args[0].(*model.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_UserFeed_Call) Return(feeds []*model.Feed, err error) *MockStore_UserFeed_Call {
	_c.Call.Return(feeds, err)
	return _c
}

func (_c *MockStore_UserFeed_Call) RunAndReturn(run func(user *model.User) ([]*model.Feed, error)) *MockStore_UserFeed_Call {
	_c.Call.Return(run)
	return _c
}

// WorkflowGetTree provides a mock function for the type MockStore
func (_mock *MockStore) WorkflowGetTree(pipeline *model.Pipeline) ([]*model.Workflow, error) {
	ret := _mock.Called(pipeline)

	if len(ret) == 0 {
		panic("no return value specified for WorkflowGetTree")
	}

	var r0 []*model.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline) ([]*model.Workflow, error)); ok {
		return returnFunc(pipeline)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline) []*model.Workflow); ok {
		r0 = returnFunc(pipeline)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Pipeline) error); ok {
		r1 = returnFunc(pipeline)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_WorkflowGetTree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WorkflowGetTree'
type MockStore_WorkflowGetTree_Call struct {
	*mock.Call
}

// WorkflowGetTree is a helper method to define mock.On call
//   - pipeline *model.Pipeline
func (_e *MockStore_Expecter) WorkflowGetTree(pipeline interface{}) *MockStore_WorkflowGetTree_Call {
	return &MockStore_WorkflowGetTree_Call{Call: _e.mock.On("WorkflowGetTree", pipeline)}
}

func (_c *MockStore_WorkflowGetTree_Call) Run(run func(pipeline *model.Pipeline)) *MockStore_WorkflowGetTree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_WorkflowGetTree_Call) Return(workflows []*model.Workflow, err error) *MockStore_WorkflowGetTree_Call {
	_c.Call.Return(workflows, err)
	return _c
}

func (_c *MockStore_WorkflowGetTree_Call) RunAndReturn(run func(pipeline *model.Pipeline) ([]*model.Workflow, error)) *MockStore_WorkflowGetTree_Call {
	_c.Call.Return(run)
	return _c
}

// WorkflowLoad provides a mock function for the type MockStore
func (_mock *MockStore) WorkflowLoad(n int64) (*model.Workflow, error) {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for WorkflowLoad")
	}

	var r0 *model.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*model.Workflow, error)); ok {
		return returnFunc(n)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *model.Workflow); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_WorkflowLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WorkflowLoad'
type MockStore_WorkflowLoad_Call struct {
	*mock.Call
}

// WorkflowLoad is a helper method to define mock.On call
//   - n int64
func (_e *MockStore_Expecter) WorkflowLoad(n interface{}) *MockStore_WorkflowLoad_Call {
	return &MockStore_WorkflowLoad_Call{Call: _e.mock.On("WorkflowLoad", n)}
}

func (_c *MockStore_WorkflowLoad_Call) Run(run func(n int64)) *MockStore_WorkflowLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_WorkflowLoad_Call) Return(workflow *model.Workflow, err error) *MockStore_WorkflowLoad_Call {
	_c.Call.Return(workflow, err)
	return _c
}

func (_c *MockStore_WorkflowLoad_Call) RunAndReturn(run func(n int64) (*model.Workflow, error)) *MockStore_WorkflowLoad_Call {
	_c.Call.Return(run)
	return _c
}

// WorkflowUpdate provides a mock function for the type MockStore
func (_mock *MockStore) WorkflowUpdate(workflow *model.Workflow) error {
	ret := _mock.Called(workflow)

	if len(ret) == 0 {
		panic("no return value specified for WorkflowUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Workflow) error); ok {
		r0 = returnFunc(workflow)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_WorkflowUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WorkflowUpdate'
type MockStore_WorkflowUpdate_Call struct {
	*mock.Call
}

// WorkflowUpdate is a helper method to define mock.On call
//   - workflow *model.Workflow
func (_e *MockStore_Expecter) WorkflowUpdate(workflow interface{}) *MockStore_WorkflowUpdate_Call {
	return &MockStore_WorkflowUpdate_Call{Call: _e.mock.On("WorkflowUpdate", workflow)}
}

func (_c *MockStore_WorkflowUpdate_Call) Run(run func(workflow *model.Workflow)) *MockStore_WorkflowUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Workflow
		if args[0] != nil {
			arg0 = args[0].(*model.Workflow)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_WorkflowUpdate_Call) Return(err error) *MockStore_WorkflowUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_WorkflowUpdate_Call) RunAndReturn(run func(workflow *model.Workflow) error) *MockStore_WorkflowUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// WorkflowsCreate provides a mock function for the type MockStore
func (_mock *MockStore) WorkflowsCreate(workflows []*model.Workflow) error {
	ret := _mock.Called(workflows)

	if len(ret) == 0 {
		panic("no return value specified for WorkflowsCreate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]*model.Workflow) error); ok {
		r0 = returnFunc(workflows)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_WorkflowsCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WorkflowsCreate'
type MockStore_WorkflowsCreate_Call struct {
	*mock.Call
}

// WorkflowsCreate is a helper method to define mock.On call
//   - workflows []*model.Workflow
func (_e *MockStore_Expecter) WorkflowsCreate(workflows interface{}) *MockStore_WorkflowsCreate_Call {
	return &MockStore_WorkflowsCreate_Call{Call: _e.mock.On("WorkflowsCreate", workflows)}
}

func (_c *MockStore_WorkflowsCreate_Call) Run(run func(workflows []*model.Workflow)) *MockStore_WorkflowsCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []*model.Workflow
		if args[0] != nil {
			arg0 = args[0].([]*model.Workflow)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_WorkflowsCreate_Call) Return(err error) *MockStore_WorkflowsCreate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_WorkflowsCreate_Call) RunAndReturn(run func(workflows []*model.Workflow) error) *MockStore_WorkflowsCreate_Call {
	_c.Call.Return(run)
	return _c
}

// WorkflowsReplace provides a mock function for the type MockStore
func (_mock *MockStore) WorkflowsReplace(pipeline *model.Pipeline, workflows []*model.Workflow) error {
	ret := _mock.Called(pipeline, workflows)

	if len(ret) == 0 {
		panic("no return value specified for WorkflowsReplace")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Pipeline, []*model.Workflow) error); ok {
		r0 = returnFunc(pipeline, workflows)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_WorkflowsReplace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WorkflowsReplace'
type MockStore_WorkflowsReplace_Call struct {
	*mock.Call
}

// WorkflowsReplace is a helper method to define mock.On call
//   - pipeline *model.Pipeline
//   - workflows []*model.Workflow
func (_e *MockStore_Expecter) WorkflowsReplace(pipeline interface{}, workflows interface{}) *MockStore_WorkflowsReplace_Call {
	return &MockStore_WorkflowsReplace_Call{Call: _e.mock.On("WorkflowsReplace", pipeline, workflows)}
}

func (_c *MockStore_WorkflowsReplace_Call) Run(run func(pipeline *model.Pipeline, workflows []*model.Workflow)) *MockStore_WorkflowsReplace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Pipeline
		if args[0] != nil {
			arg0 = args[0].(*model.Pipeline)
		}
		var arg1 []*model.Workflow
		if args[1] != nil {
			arg1 = args[1].([]*model.Workflow)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_WorkflowsReplace_Call) Return(err error) *MockStore_WorkflowsReplace_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_WorkflowsReplace_Call) RunAndReturn(run func(pipeline *model.Pipeline, workflows []*model.Workflow) error) *MockStore_WorkflowsReplace_Call {
	_c.Call.Return(run)
	return _c
}
